29/04/2020 WINDOWS POWERSHELL
Configure iis
$ Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename
Store theses value in variable $<variable name>
$iisfeatures=Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename 

foreach($item in $iisfeatures.featurename){Enable-WindowsOptionalFeature -FeatureName $item -Online -Verbose}

cmdlet
commands are built in the form of verb-noun format
$ get-command    to list all commands
$ import-module webadministration -Verbose
$ get-command -Module webadministration

TO CHECK OPEN RUN(win+R) and type " inetmgr "
-Force is for conformation
-Verbose 

WIN ISE
Import-Module WebAdministration
New-WebAppPool -Name "RAJA" -Force   # To create a AppPools user 
$result=Get-Item IIS:\AppPools\RAJA -Force # To store appPool data to result 
$result |Format-List *                 # TO list the values stored in value
$result.managedPipelineMode="Classic"  # to change the parameter
$result.enable32BitAppOnWin64=$true  #for boolean true or false denote as a variable $true
$result.queueLength=65535
$result|Set-Item -Force -verbose       # to load the parameter in IIS

30/04/2020
Same as above with comments

//

01/05/2020

if (condition){
# True Block
}
else{
# False Block
}

Import-Module WebAdministration

if(Test-Path IIS:\AppPools\reddy)
{
Write-warning "The following block Already Exists"
#Removing existing App Pool
Remove-Item IIS:\AppPools\reddy -Force -Recurse -Verbose
# Create New pool
New-WebAppPool -Name Reddy -Force -Verbose
}

else
{
Write-warning "The following block doesnot Exists. So creating New"
#create newweb app pool cmdlet
New-WebAppPool -Name Reddy -Force -Verbose
 
}

# To Remove restriction error
$ Get-ExecutionPolicy
$ Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Verbose
Give File path to execute
'H:\AZURE\POWER SHELL PROGRAM\IF condition to create webappPool.ps1'

param(
    [parameter (Mandatory=$true)]
    [string]$pool
)


Import-Module webadministration

if(Test-path IIS:\AppPools\$pool)
{
    # If above condition is true then this block statement will be execute
    Write-Warning " The following Application Pool:$pool Already exist"
    # Removing the existing application Pool
    #Remove-WebAppPool
    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose

}
else{
    # If above if condition failed then this else block statements will execute
    Write-Host "The followig Application Pool:$pool deos not exist. Hence creating new" -ForegroundColor Red
   
}

   #create new-app pool
    New-WebAppPool -Name $pool -Force -Verbose

    # fetch the applicaition pool using get-item and store the value into variable $result 

    $result=Get-Item IIS:\AppPools\$pool -Force -Verbose

    #modify queuelength = 7000

    $result.queueLength=7000

    # managed run time version  v2.0

    $result.managedRuntimeVersion="v2.0"

    #manage pipeline mode as  Classic

    $result.managedPipelineMode="Classic"

    # enable32bit appon win 64 set as True

    $result.enable32BitAppOnWin64=$true

    # set the above new values to existing app-pool

    $result | Set-Item -Force -Verbose

02/05/2020

param(
  [parameter (Mandatory=$true)]
  [string]$Pool,
  [parameter (Mandatory=$true)]
  [string]$Version,
  [parameter (Mandatory=$true)]
  [string]$mode,
  [parameter (Mandatory=$true)]
  [bool]$enable32bit,
  [parameter (Mandatory=$true)]
  [int]$queuelength

)
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

#check the App-pool name should not empty
if($Pool -ne "" -and $Pool -ne $null)
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if($Version -ne "" -and $Version -ne $null)
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if($mode -ne $null -and $mode -ne "")
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if($queuelength -ge 10 -and $queuelength -le 65535){

$result.queueLength=$queuelength
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}

#update enable32bit (value should True or False)
if("$enable32bit" -ne $null -and "$enable32bit" -ne "")
{
if($enable32bit -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}



05/05/2020
App pool Identity
1. Build-In Account
  a. Local Service
  b. Local System
  c. Network Service
  d. App pool Identity
2. Custom Account
https://www.advancedinstaller.com/user-guide/iis-app-pool-identity.html

param(
  
 [string[]]$Pools,
 $Version,
 $mode,
 $enable32bit,
 $queuelength,
 $identiytype,
 $user,
 $password

)

$Pool="abc","xyz","123"
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

foreach ($pool in $Pools){

#check the App-pool name should not empty
if(-not([string]::IsNullOrWhiteSpace($Pool)))
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if(-not([string]::IsNullOrWhiteSpace($Version)))
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if(-not([string]::IsNullOrWhiteSpace($mode)))
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if(-not([string]::IsNullOrWhiteSpace("$queuelength"))){
if(([convert]::ToInt16($queuelength) -ge 10) -and ([convert]::ToInt16($queuelength) -le 65535)){

$result.queueLength=[convert]::ToInt64($queuelength)
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}
} # end of main if validation
else{
Write-Error -Message " Queuelength should not be null" -ErrorAction Stop
}

#update enable32bit (value should True or False)
if(-not([string]::IsNullOrWhiteSpace("$enable32bit")))
{
if("$enable32bit" -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

#Working with identitytype
if(-not([string]::IsNullOrWhiteSpace($identiytype)))
{
    if($identiytype -eq "LocalService")
    {
        $result.processModel.identityType="LocalService"
    }
    elseif($identiytype -eq "LocalSystem")
    {
        $result.processModel.identityType="LocalSystem"
    }
    elseif($identiytype -eq "NetworkService")
    {
        $result.processModel.identityType="NetWorkService"
    }
    elseif($identiytype -eq "SpecificUser")
    {
        $result.processModel.identityType="SpecificUser"
        $result.processModel.userName=$user
        $result.processModel.password=$password
    }
    else{
        Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor Green
        $result.processModel.identityType="Applicationpoolidentiy"
    }

}
else{
    Write-warnig -Message "Identity should not be empty and values must be Local System, Local Service, Network Service, Application-pool identity and Specific . By default Applicationpoolidentiy was set"
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}
}

07/05/2020
<APPpool.json> file

{
    "Name": "Kumar",
    "Version": "v2.0",
    "Mode": "Classic",
    "QueLength": 9909,
    "Enable32bit": true,
    "identityType": "LocalSystem",
    "UserName": "",
    "Password": ""
}

<AppPool.ps1> file

$data = Get-Content -Path H:\Azure\POWERSHELL\appPool.json | ConvertFrom-Json

$pool = $data.Name
$version = $data.Version
$mode = $data.Mode
$quelength = $data.QueLength
$enable32bit = $data.Enable32bit
$identitytype = $data.identityType
$username = $data.Username
$password = $data.Password

if(![string]::IsNullOrWhiteSpace($pool))
    {
        Import-Module webAdministration
        if(Test-Path IIS:\AppPools\$pool)
        {
            Write-Warning "The Application pool: $pool already exists, so removing the pool"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -verbose
            Write-Host "The AppPool: $pool deleted successfully" -ForegroundColor Green
        }
        else
        {
            Write-Host "The Application Pool: $pool does not exist, hence creating new one." -ForegroundColor White
        }

        New-WebAppPool -Name $pool -Force -Verbose
        Write-Host "The AppPool: $pool created successfully" -ForegroundColor Green

        $result =  Get-Item IIS:\AppPools\$pool -Force -verbose

        #Version
        if(![string]::IsNullOrWhiteSpace($version))
        {
            if($version -eq "v2.0" -or $version -eq "v4.0")
            {
                $result.managedRuntimeVersion = $version
            }
            elseif($version -eq "No Managed Code")
            {
                $result.managedRuntimeVersion = ""
            }
            else
            {
                Write-Error -Message "Invalid Version value. Version should be v2.0/v4.0/No Managed Code" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Version should not be empty" -ErrorAction Stop
        }

        #Mode
        if(![string]::IsNullOrWhiteSpace($mode))
        {
            if($mode -eq "Integrated" -or $mode -eq "Classic")
            {
                $result.managedPipelineMode = $mode
            }
            else
            {
                Write-Error -Message "Invalid Mode value, mode should be Integrated/Classic" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Mode should not be empty" -ErrorAction Stop
        }

        #Queue Length
        if(![string]::IsNullOrWhiteSpace($quelength))
        {
            if(([convert]::ToInt32($quelength) -ge 10) -and ([convert]::ToInt32($quelength) -le 65535))
            {
                $result.queueLength = [Convert]::ToInt32($quelength)
            }
            else
            {
                Write-Error -Message "Invalid Range Passed, range should be 10 to 65535" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Queue Length Should not be empty" -ErrorAction Stop
        }

        #Enable32bit
        if(![string]::IsNullOrWhiteSpace($enable32bit))
        {
            if("$enable32bit" -eq "True")
            {
                $result.enable32BitAppOnWin64 = $true
            }
            else
            {
                $result.enable32BitAppOnWin64 = $false
            }
        }
        else
        {
            Write-Error -Message "Enable32bit should not be empty" -ErrorAction Stop
        }

        #Identity Type
        if(![string]::IsNullOrWhiteSpace($identitytype))
        {
            if($identitytype -eq "LocalSystem")
            {
                $result.processModel.identityType = "LocalSystem"
            }
            elseif($identitytype -eq "LocalService")
            {
                $result.processModel.identityType = "LocalService"
            }
            elseif($identitytype -eq "NetworkService")
            {
                $result.processModel.identityType = "NetworkService"
            }
            elseif($identitytype -eq "SpecificUser")
            {
                $result.processModel.identityType = $identitytype
                $result.processModel.userName = $username
                $result.processModel.password = $password
            }
            else
            {
                $result.processModel.identityType = "ApplicationPoolIdentity"
            }
        }
        else
        {
            Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor White
            Write-Error -Message "Identity Type should not be empty" -ErrorAction Stop
        }

        $result | Set-Item -Force -Verbose
    }
    else
    {
        Write-Error -Message "The Application name should not be empty" -ErrorAction Stop
    }
	
	
---------------------------------

$Data=Get-Content -Path D:\Devops\AZ-800\pool.json | ConvertFrom-Json
#load the JSON values into  local varaibles

$pool=$data.Name
$version=$Data.version
$mode=$Data.mode
$queuelength=$Data.queuelength
$enable32bit=$Data.enable32bit
$identity=$Data.identitytype
$user=$Data.username
$password=$Data.password

#validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration -Verbose
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}


{
    "Name":"Json",
    "version":"v4.0",
    "mode":"Integrated",
    "queuelength":9999,
    "enable32bit":false,
    "identitytype":"SpecificUser",
    "username":"Test80",
    "password":"India@123"

}	

08/05/2020
$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.userName
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force -Verbose
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
}


----------

{
    "IISDeploy":{
        "AppPools":[
            {"First":{"Name":"FirstApp","version":"v2.0","mode":"Classic","queuelength":1111,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Second":{"Name":"Raja","version":"v2.0","mode":"Classic","queuelength":1112,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Third":{"Name":"Shekar","version":"v4.0","mode":"Integrated","queuelength":1113,"enable32bit":false,"identitytype":"LocalSystem","username":"RAJA","password":"crsreddy1447"}},
            {"Fourth":{"Name":"Reddy","version":"v4.0","mode":"Integrated","queuelength":8855,"enable32bit":false,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Fifth":{"Name":"FifthApp","version":"v2.0","mode":"Classic","queuelength":3333,"enable32bit":true,"identitytype":"LocalService","username":"RAJA","password":"crsreddy1447"}}
        ]
    }

}


TASK: How to handle custome app-pool execution  (selected app-pool execution )

----------
09/05/2020


param(
    [parameter (Mandatory=$true)]
    [string[]]$components
)

$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($components.Length -ne 0){
foreach($item in $components){
    Write-Host "Working on selected app-pool:$item" -ForegroundColor Green
    if($Apppools -contains $item){
            Write-Host "Working on App-pool :$item" -ForegroundColor Green
            ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
            # load the variables from json for specific app-pool
            
            $pool=$i.$item.Name
            $version=$i.$item.version
            $mode=$i.$item.mode
            $queuelength=$i.$item.queuelength
            $enable32bit=$i.$item.enable32bit
            $identity=$i.$item.identityType
            $user=$i.$item.username
            $password=$i.$item.password
    
            #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
    if(-not ([string]::IsNullOrWhiteSpace($pool))){
        #import module webadministration
        Import-Module webadministration
        #test the app-pool  exist or not . if exist then delete or set mesaage
        if(Test-Path IIS:\AppPools\$pool){
            Write-Warning "The given App-pool:$pool already exist. Hence removing"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
        }
        else {
            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
        } 
        
        #create new webapppool
        New-WebAppPool -Name $pool -Force
        #load the above created app-pool into local varaible
        $result=Get-Item IIS:\AppPools\$pool -Force
    
        #validate managed runtime version
        if(-not([string]::IsNullOrWhiteSpace($version))){
            if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                $result.managedRuntimeversion=$version
            }
            elseif($version -eq "No Managed Code"){
                $result.managedRuntimeversion=""
            }
            else{
                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message " version should not be empty" -ErrorAction Stop
        }
    
        #validate managed pipeline mode
        if(-not([string]::IsNullOrWhiteSpace($mode))){
            if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                $result.ManagedPipelineMode=$mode
            }
            else {
                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
        }
        #validate queuelength
        if(-not([string]::IsNullOrWhiteSpace($queuelength))){
            if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                $result.queuelength=[convert]::ToInt64($queuelength)
            }
            else {
                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
            }
        }
        else {
            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
        }
        #validate enable32bit
        if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
            if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                $result.enable32BitAppOnWin64=$enable32bit
            }
            else {
                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
        }
    
        #validate identity
        if(-not ([string]::IsNullOrWhiteSpace($identity))){
            if($identity -eq "LocalSystem"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "LocalService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "NetworkService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "SpecificUser"){
                $computer=$env:COMPUTERNAME
                Add-type -AssemblyName system.directoryservices.AccountManagement
                $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                $credstatus=$creds.ValidateCredentials($user, $password)
                if($credstatus -eq "true"){
                    $result.processModel.identityType="SpecificUser"
                    $result.processModel.userName=$user
                    $result.processModel.password=$password
                }
                else {
                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                }
            }
            else{
                Write-Warning "No matching identitytype found .hence applying default" 
                $result.Processmodel.identitytype="ApplicationPoolIdentity"
            }
        }
        else{
            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
        }
    
        $result |Set-Item -Force -Verbose
    }# end of main if pool
    else{
        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
    }
    
        
    }
    else{
        Write-Error -Message " the given component : $item doesnot exist in JSON" -ErrorAction 
    }
}
}
else{
if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.user
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
} 
}

------------------
12/05/2020

{
    "IISDeploy":{
        "Sites":[
            {"Google":{"Name":"Google","port":80,"physicalpath":"D:/Devops/IIS/Sites","Apppool":"Google"}}
        ]
    } 
}
$data=Get-Content -Path H:\AZURE\POWERSHELL\sites.json | ConvertFrom-Json
#Declare Empty Variable
$sites=@()
# Assigning json value to enpty variable
($data.IISDeploy.Sites).Foreach{
    $sites+=$_.psobject.properties.name
    
}
#validate sites length should not be 0
if($sites.length -ne 0)
{
    foreach($item in $sites)
    {
        Write-Host "Working on Sites" -ForegroundColor Green
        ($j=$data.IISDeploy.Sites)|Where-Object{$_.Name -eq $item}
        $sites=$j.$item.Name
        $port=$j.$item.port
        $physicalpath=($j.$item.physicalpath).Replace("/","\")
        $pool=$j.$item.Apppool

        # Valid site name should not be empty
        if($sites.length -ne 0)
        {
            Import-Module WebAdministration
            if(Test-Path IIS:\Sites\$sites)
            {
                Write-Warning "The given site :$sites found. Hence deleting"
                Remove-Item IIS:\Sites\$sites -Force -Verbose -Recurse
            }
            else 
            {
                Write-Host "No site found with name of :$sites. hence creating new" -ForegroundColor Green 
                
            }
            #Validate physical path
            if ($physicalpath.Length -ne 0) 
            {
                #Test the physical path
                if (Test-Path $physicalpath\$sites) 
                {
                    Write-Warning "Physicalpath :$physicalpath already exist .hence Deleting"
                    Remove-Item $physicalpath\$sites -Force -Recurse -Verbose
                }
                else 
                {
                    Write-Host "Physicalpath :$physicalpath\$sites doesnot exit. Hence creating new" -ForegroundColor Green
                }
                #create physical Path
                New-Item $physicalpath\$sites -ItemType Directory -Force -Verbose


            }
            else
            {
                Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
            } # end of the physical path condition
            #validate the port
            if($port.length -ne 0)
            {
                New-Website -Name $sites -Port $port -PhysicalPath $physicalpath -ApplicationPool $pool -Force -ErrorAction Stop
            }
            else
            {
                Write-Error "Port number should not be empty .hence aborting the process" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop 
        }
    }
}
else
{
    Write-Error -Message "Sites length should not Zero. please verify JSON" -ErrorAction stop
}


-----------------
13/05/2020

$Data=Get-Content -Path H:\AZURE\POWERSHELL\sitespool.json |ConvertFrom-Json

#decalre empty array
$sites=@()
($Data.IISDeploy.Sites).ForEach{$sites+=$_.psobject.properties.name}

#validate sites length should not be 0
if($sites.Length -ne 0){foreach($item in $sites)
    {
        Write-Host "Working on website: $item" -ForegroundColor Green
        ($j=$Data.IISDeploy.Sites)|Where-Object{$_.Name -eq $item}
            $sites=$j.$item.Name
            $port=$j.$item.port
            $physicalpath=($j.$item.physicalpath).Replace("/","\")
            $Apppool=$j.$item.Apppool

            if($Apppool.Length -ne 0)
            {
                Write-Host " Working on App-pool:$Apppool deployment" -ForegroundColor green
                ($i=$Data.IISDeploy.AppPools)| Where-Object{$_.name -eq $Apppool}
                # load the variables from json for specific app-pool
                    $pool=$i.$Apppool.name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identitytype
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
                        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                if(-not ([string]::IsNullOrWhiteSpace($pool)))
                {
                    #import module webadministration
                    Import-Module webadministration
                    #test the app-pool  exist or not . if exist then delete or set mesaage
                    if(Test-Path IIS:\AppPools\$pool)
                    {
                        Write-Warning "The given App-pool:$pool already exist. Hence removing"
                        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                    }
                    else 
                    {
                        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                    } 
                    
                    #create new webapppool
                    New-WebAppPool -Name $pool -Force
                    #load the above created app-pool into local varaible
                    $result=Get-Item IIS:\AppPools\$pool -Force
                
                    #validate managed runtime version
                    if(-not([string]::IsNullOrWhiteSpace($version)))
                    {
                        if(($version -eq "v2.0") -or ($version -eq "v4.0"))
                        {
                            $result.managedRuntimeversion=$version
                        }
                        elseif($version -eq "No Managed Code")
                        {
                            $result.managedRuntimeversion=""
                        }
                        else
                        {
                            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message " version should not be empty" -ErrorAction Stop
                    }
                
                    #validate managed pipeline mode
                    if(-not([string]::IsNullOrWhiteSpace($mode)))
                    {
                        if(($mode -eq "Integrated") -or ($mode -eq "Classic"))
                        {
                            $result.ManagedPipelineMode=$mode
                        }
                        else 
                        {
                            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                    }
                    #validate queuelength
                    if(-not([string]::IsNullOrWhiteSpace($queuelength)))
                    {
                        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535))
                        {
                            $result.queuelength=[convert]::ToInt64($queuelength)
                        }
                        else 
                        {
                            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                    }
                    #validate enable32bit
                    if(-not([string]::IsNullOrWhiteSpace($enable32bit)))
                    {
                        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False"))
                        {
                            $result.enable32BitAppOnWin64=$enable32bit
                        }
                        else 
                        {
                            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                    }
                
                    #validate identity
                    if(-not ([string]::IsNullOrWhiteSpace($identity)))
                    {
                        if($identity -eq "LocalSystem")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "LocalService")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "NetworkService")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "SpecificUser")
                        {
                            $computer=$env:COMPUTERNAME
                            Add-type -AssemblyName system.directoryservices.AccountManagement
                            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                            $credstatus=$creds.ValidateCredentials($user, $password)
                            if($credstatus -eq "true")
                            {
                                $result.processModel.identityType="SpecificUser"
                                $result.processModel.userName=$user
                                $result.processModel.password=$password
                            }
                            else 
                            {
                                Write-Error -Message "Invalid credentials" -ErrorAction Stop
                            }
                        }
                        else
                        {
                            Write-Warning "No matching identitytype found .hence applying default" 
                            $result.Processmodel.identitytype="ApplicationPoolIdentity"
                        }
                    }
                    else
                    {
                        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                    }
                
                    $result |Set-Item -Force -Verbose
                }# end of main if pool
                else
                {
                    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                }
                
                    


            }
            else 
            {
                Write-Error -Message "Pool name should not be empty. Hence aborting the process" -ErrorAction stop
            }
            #valite sitename should not be empty
            if($sites.Length -ne 0)
            {
                #import the module webadministration
                Import-Module WebAdministration
                if(Test-Path IIS:\Sites\$sites)
                {
                    Write-Warning " the given site : $sites found .Hence deleting"
                    Remove-Item IIS:\Sites\$sites -Force -Recurse -Verbose
                }
                else
                {
                    Write-Host "No site found with name of :$sites. hence creating new" -ForegroundColor Green
                }

                #validate physicalpath 
                if($physicalpath.Length -ne 0)
                {
                    # test the physicalpath 
                    if(Test-path $physicalpath\$sites)
                    {
                        Write-Warning "Physicalpath :$physicalpath already exist .hence Deleting"
                        Remove-Item $physicalpath\$sites -Force -Recurse -Verbose
                    }
                    else
                    {
                        Write-Host "Physicalpath :$physicalpath\$site doesnot exit. Hence creating new" -ForegroundColor Green
                    }
                    #creating physicalpath
                    New-Item $physicalpath\$sites -ItemType Directory -Force -Verbose

                }
                else
                {
                    Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
                } # end physicalpath condition

                #validate port and create newwebsite
                if($port.length -ne 0)
                {
                    New-Website -Name $sites -Port $port -PhysicalPath $physicalpath -ApplicationPool $pool -Force -ErrorAction Stop
                }
                else
                {
                    Write-Error "Port numbe should not be empty .hence aborting the process" -ErrorAction Stop
                }
            }
            else
            {
                Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop
            }
            
    }
}
else
{
    Write-Error -Message "Sites length should not Zero. please verify JSON" -ErrorAction stop
}

<JSON>

{
    "IISDeploy":{
        "AppPools":[
            {"Raja":{"name":"Raja","version":"v2.0","mode":"Classic","queuelength":4444,"enable32bit":true,"identitytype":"LocalSystem","user":"","password":""}},
            {"Shekar":{"name":"Shekar","version":"v4.0","mode":"Integrated","queuelength":5555,"enable32bit":false,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}},
            {"Reddy":{"name":"Reddy","version":"v2.0","mode":"Classic","queuelength":6666,"enable32bit":true,"identitytype":"LocalService","user":"","password":""}},
            {"CRSR":{"name":"CRSR","version":"v4.0","mode":"Integrated","queuelength":7777,"enable32bit":false,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}},
            {"SIVA":{"name":"SIVA","version":"v2.0","mode":"Classic","queuelength":9999,"enable32bit":true,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"Google":{"Name":"Google","port":85,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Raja"}},
            {"Microsoft":{"Name":"Microsoft","port":81,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Shekar"}},
            {"CTS":{"Name":"CTS","port":82,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Reddy"}},
            {"Eron":{"Name":"Eron","port":83,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"CRSR"}},
            {"GL":{"Name":"GL","port":84,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"SIVA"}}
            

        ]
    }
}

------------------
15/05/2020

#Load the data from JSON
$Data=get-content -Path H:\AZURE\POWERSHELL\Auth.json|ConvertFrom-Json

#Declare empty array for sites
$sites=@() # empty array means 0 objects

#let gather sites information from JSON
($Data.IISDeploy.Sites).ForEach{
    $sites+=$_.psobject.properties.name
}

#validate sites.length
if($sites.Length -ne 0){
    foreach($item in $sites){
        Write-host "Working on Site : $item deployment" -foregroundcolor green
        ($j=$Data.IISDeploy.Sites)|Where-Object {$_.Name -eq $item}

            $site=$j.$item.Name
            $port=$j.$item.port
            $physicalpath=($j.$item.physicalpath).Replace("/","\")
            $Apppool=$j.$item.Apppool
            $anonymous=$j.$item.Anonymous
            $windows=$j.$item.windows

            # validate app-pool name and initate the process for app-pool deployment
            if($Apppool.Length -ne 0){
                # load the app-pool information from JSON
                ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $Apppool}
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool=$i.$Apppool.Name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identity
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
            if(-not ([string]::IsNullOrWhiteSpace($pool))){
                #import module webadministration
                Import-Module webadministration
                #test the app-pool  exist or not . if exist then delete or set mesaage
                if(Test-Path IIS:\AppPools\$pool){
                    Write-Warning "The given App-pool:$pool already exist. Hence removing"
                    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                }
                else {
                    Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                } 
                
                #create new webapppool
                New-WebAppPool -Name $pool -Force
                #load the above created app-pool into local varaible
                $result=Get-Item IIS:\AppPools\$pool -Force
            
                #validate managed runtime version
                if(-not([string]::IsNullOrWhiteSpace($version))){
                    if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                        $result.managedRuntimeversion=$version
                    }
                    elseif($version -eq "No Managed Code"){
                        $result.managedRuntimeversion=""
                    }
                    else{
                        Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message " version should not be empty" -ErrorAction Stop
                }
            
                #validate managed pipeline mode
                if(-not([string]::IsNullOrWhiteSpace($mode))){
                    if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                        $result.ManagedPipelineMode=$mode
                    }
                    else {
                        Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                }
                #validate queuelength
                if(-not([string]::IsNullOrWhiteSpace($queuelength))){
                    if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                        $result.queuelength=[convert]::ToInt64($queuelength)
                    }
                    else {
                        Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                    }
                }
                else {
                    Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                }
                #validate enable32bit
                if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
                    if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                        $result.enable32BitAppOnWin64=$enable32bit
                    }
                    else {
                        Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                }
            
                #validate identity
                if(-not ([string]::IsNullOrWhiteSpace($identity))){
                    if($identity -eq "LocalSystem"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "LocalService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "NetworkService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "SpecificUser"){
                        $computer=$env:COMPUTERNAME
                        Add-type -AssemblyName system.directoryservices.AccountManagement
                        $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                        $credstatus=$creds.ValidateCredentials($user, $password)
                        if($credstatus -eq "true"){
                            $result.processModel.identityType="SpecificUser"
                            $result.processModel.userName=$user
                            $result.processModel.password=$password
                        }
                        else {
                            Write-Error -Message "Invalid credentials" -ErrorAction Stop
                        }
                    }
                    else{
                        Write-Warning "No matching identitytype found .hence applying default" 
                        $result.Processmodel.identitytype="ApplicationPoolIdentity"
                    }
                }
                else{
                    Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                }
            
                $result |Set-Item -Force -Verbose
            }# end of main if pool
            else{
                Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
            }
            
                
            }
            else{
                Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
            }

            #begin site deployment
            if($site.Length -ne 0){
                Import-Module webadministration
                if(Test-Path IIS:\Sites\$site){
                    Write-warning "Sites already exist with name: $site. Hence deleting" 
                    Remove-item IIS:\Sites\$site -Force -Recurse -Verbose
                }
                else{
                    Write-Host "No Site found with name of $site. hence creating new" -ForegroundColor Green
                }
                #validate physicalpath
                if(Test-Path $physicalpath\$site){
                    Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                    Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                }
                else{
                    Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                }

                New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                #validate port
                if(($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)){
                    #create website
                    New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                }
                else{
                    Write-Error -Message "Port value must be set" -ErrorAction Stop
                }

                # apply Anonymous authentication
                if($anonymous.length -ne 0){
                    if("$anonymous" -eq "True" -or "$anonymous" -eq "false"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    else{
                        Write-Warning "Invalid input provided . value must be true or false"
                    }
                }
                else{
                    Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                }
                # apply windows authentication
                if($windows.length -ne 0){
                    if($windows -eq "windows"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "basic"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "digest"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    else{
                        Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                    }
                
                }
                else {
                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                }

            }
            else {
                Write-Error -message "Site name cannot be empty. Hence aborting the process" -ErrorAction stop            }
            
    }
}
else {
    Write-Error -Message "Sites length should not be zero. hence aborting the process" -ErrorAction Stop
}



{
    "IISDeploy":{
        "AppPools":[
            {"Aviva":{"Name":"Aviva","mode":"Integrated","version":"v4.0","queuelength":12345,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"Aviva":{"Name":"Aviva","port":89,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic" }}
        ]
    } 
}

Task : Component deployment for site

10 Sites -- 5 apppools ( 1 app pool need assign for two sites)

1,3,5,7,9  ( names of base numbers as components)


{
    "IISDeploy":{
        "Apppools":[
            {"A1":{"Name":"A1","mode":"Classic","version":"v4.0","queuelength":12345,"enable32bit":true,"identity":"LocalService","user":"","password":""}},
            {"A2":{"Name":"A2","mode":"Integrated","version":"v2.0","queuelength":5555,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}},
            {"A3":{"Name":"A3","mode":"Classic","version":"v4.0","queuelength":3333,"enable32bit":true,"identity":"LocalSystem","user":"","password":""}}
            
            
        ],
        "Sites":[
            {"APPLE1":{"Name":"APPLE1","id":1,"port":81,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic" }},
            {"APPLE2":{"Name":"APPLE2","id":2,"port":82,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":true,"windows":"windowsbasic" }},
            {"APPLE3":{"Name":"APPLE3","id":3,"port":83,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windows" }},
            {"APPLE4":{"Name":"APPLE4","id":4,"port":84,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic" }},
            {"APPLE5":{"Name":"APPLE5","id":5,"port":85,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic" }},
            {"APPLE6":{"Name":"APPLE6","id":6,"port":86,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":true,"windows":"windows" }}
        ]
    } 
}



------------
19/05/2020

$data=Get-Content H:\AZURE\POWERSHELL\Authvsites.json |ConvertFrom-Json
#create empty array
$vsites=@()
#load vsites from json into empty array
($data.IISDeploy.Vsites).ForEach{
    $vsites+=$_.psobject.properties.name
}

#valiate virtualsites lenght
if($vsites.Length -ne 0)
{
    foreach($item in $vsites)
	{
        Write-Host " Data reading process begin for virtual site :$item" -ForegroundColor Green
        ($k=$data.IISDeploy.Vsites)|Where-Object{$_.Name -eq $item}

            $vsite=$k.$item.Name
            $vwebsite=$k.$item.site
            $vphysicalpath=($k.$item.physicalpath).replace("/","\")
            $vanonymous=$k.$item.anonymous
            $vwindows=$k.$item.windows
            $vimpersonate=$k.$item.impersonate

                #lets load the website detials
                if($vwebsite.Length -ne 0){
                    ($j=$data.IISDeploy.Sites)|Where-Object{$_.name -eq $vwebsite}
                    
                    $site=$j.$vwebsite.Name
                    $port=$j.$vwebsite.port
                    $physicalpath=($j.$vwebsite.physicalpath).replace("/","\")
                    $anonymous=$j.$vwebsite.anonymous
                    $windows=$j.$vwebsite.windows
                   #$impersonate=$j.$vwebsite.impersonate
                    $apppool=$j.$vwebsite.apppool

                    Import-Module WebAdministration
                    #load the app-pool info from JSON
                    # validate app-pool name and initate the process for app-pool deployment
                if($Apppool.Length -ne 0){
                # load the app-pool information from JSON
                ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $Apppool}
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool=$i.$Apppool.Name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identity
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
            if(-not ([string]::IsNullOrWhiteSpace($pool))){
                #import module webadministration
                Import-Module webadministration
                #test the app-pool  exist or not . if exist then delete or set mesaage
                if(Test-Path IIS:\AppPools\$pool){
                    Write-Warning "The given App-pool:$pool already exist. Hence removing"
                    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                }
                else {
                    Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                } 
                
                #create new webapppool
                New-WebAppPool -Name $pool -Force
                #load the above created app-pool into local varaible
                $result=Get-Item IIS:\AppPools\$pool -Force
            
                #validate managed runtime version
                if(-not([string]::IsNullOrWhiteSpace($version))){
                    if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                        $result.managedRuntimeversion=$version
                    }
                    elseif($version -eq "No Managed Code"){
                        $result.managedRuntimeversion=""
                    }
                    else{
                        Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message " version should not be empty" -ErrorAction Stop
                }
            
                #validate managed pipeline mode
                if(-not([string]::IsNullOrWhiteSpace($mode))){
                    if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                        $result.ManagedPipelineMode=$mode
                    }
                    else {
                        Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                }
                #validate queuelength
                if(-not([string]::IsNullOrWhiteSpace($queuelength))){
                    if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                        $result.queuelength=[convert]::ToInt64($queuelength)
                    }
                    else {
                        Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                    }
                }
                else {
                    Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                }
                #validate enable32bit
                if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
                    if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                        $result.enable32BitAppOnWin64=$enable32bit
                    }
                    else {
                        Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                }
            
                #validate identity
                if(-not ([string]::IsNullOrWhiteSpace($identity))){
                    if($identity -eq "LocalSystem"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "LocalService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "NetworkService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "SpecificUser"){
                        $computer=$env:COMPUTERNAME
                        Add-type -AssemblyName system.directoryservices.AccountManagement
                        $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                        $credstatus=$creds.ValidateCredentials($user, $password)
                        if($credstatus -eq "true"){
                            $result.processModel.identityType="SpecificUser"
                            $result.processModel.userName=$user
                            $result.processModel.password=$password
                        }
                        else {
                            Write-Error -Message "Invalid credentials" -ErrorAction Stop
                        }
                    }
                    else{
                        Write-Warning "No matching identitytype found .hence applying default" 
                        $result.Processmodel.identitytype="ApplicationPoolIdentity"
                    }
                }
                else{
                    Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                }
            
                $result |Set-Item -Force -Verbose
            }# end of main if pool
            else{
                Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
            }
            
                
                }
                else{
                Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                }
                Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                #website deployment begin
                Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                    if($site.lengh -ne 0){
                        if(Test-path IIS:\Sites\$site){
                            Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                        }
                        else{
                            Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                            #validate physicalpath
                            if(Test-Path $physicalpath\$site){
                                Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                                Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                            }
                            else{
                                    Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                            }
                            New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                            #validate port
                            if(($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)){
                                #create website
                                New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                            }
                            else{
                                Write-Error -Message "Port value must be set" -ErrorAction Stop
                            }

                            # apply Anonymous authentication
                            if($anonymous.length -ne 0){
                                if("$anonymous" -eq "True" -or "$anonymous" -eq "false"){
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else{
                                    Write-Warning "Invalid input provided . value must be true or false"
                                }
                            # apply windows authentication
                            if($windows.length -ne 0){
                                if($windows -eq "windows"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "basic"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "digest"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else{
                                    Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                }
                
                                }
                                else {
                                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                                }

                }
                else{
                    Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                }
                        }# end of test-path (else condtion)
                    }
                    else {
                        Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                    }
                Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green

                }# if $vwebsite
                else {
                    Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
                }

                #lets start virtual site deployment
                Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
                if($vsite.Length -ne 0){
                    if(Test-Path IIS:\Sites\$site\$vsite){
                        Write-Warning "Given Virtual site already exist. Hence deleting"
                        Remove-Item IIS:\Sites\$site\$vsite -Force -Recurse -Verbose
                    }
                    else {
                        Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                    }
                    #validate physicalpath
                    if($vphysicalpath.Length -ne 0){
                        if(Test-path $vphysicalpath\$site\$vsite){
                            Write-Warning "physicalpath already exist. Hence deleting"
                            Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                        }
                        else{
                            Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                        }

                        New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                        
                    }
                    else {
                        Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                    }
                    #create virtualsite
                    New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop

                    #authentication
                    #anonymous
                    if($vanonymous.lengh -ne 0){
                        if("$vanonymous" -eq "True" -or "$vanonymous" -eq "False"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        else {
                            Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                        }
                    
                    }
                    else {
                        Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                    }
                    #windows
                    if($vwindows.Length -ne 0){
                        if($windows -eq "windows"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        elseif($windows -eq "basic"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        else{
                            Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                        }
                    }
                    else {
                        Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                    }
                    #Aspimpersonation
                    if($vimpersonate.Length -ne 0){
                        if($vimpersonate -eq "True"){
                            cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                        }
                        else {
                            cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                        }
                    }
                    else{
                        Write-Warning "Impersonate value must true or false" 
                    }

                }# end main if ($vsite.length)
                else {
                    Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
                }
                Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green

    }# end of foreach of vistes
}# end of $vsites.lengh main block
else {
    Write-Error -Message "Vsites should not be zero. Hence abort the process" -ErrorAction Stop
}


---------
json

{
    "IISDeploy":{
        "AppPools":[
            {"Aviva":{"Name":"Aviva","mode":"Integrated","version":"v4.0","queuelength":12345,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"Aviva":{"Name":"Aviva","port":89,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic","impersonate":true }},
            {"EMC2":{"Name":"EMC2","port":91,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic","impersonate":true }},
            {"Apple":{"Name":"Apple","port":92,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic","impersonate":true }}
        ],
        "Vsites":[
            {"HCL":{"Name":"HCL","Site":"EMC2","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"F5":{"Name":"F5","Site":"Apple","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}}
        ]
    } 
}

------
<Components>

param(
    [parameter(Mandatory = $true)]
    [string[]]$comp
)
Import-Module WebAdministration
$data=Get-Content F:\azure\sitepool.json|ConvertFrom-Json
#create empty array
$vsites=@()
#load vsites from json into empty array
($data.IISDeploy.Vsites).ForEach{
    $vsites+=$_.psobject.properties.name
}
if($components.length -ne 0) 
{
foreach ($item in $comp) 
{
    Write-Host ">>>>>>>>>>>>>>Working on components:$item"
#valiate virtualsites lenght
if($vsites.Length -ne 0){
    foreach($item in $vsites){
        Write-Host " Data reading process begin for virtual site :$item" -ForegroundColor Green
        ($k=$data.IISDeploy.Vsites)|Where-Object{$_.Name -eq $item}

            $vsite=$k.$item.Name
            $vwebsite=$k.$item.site
            $vphysicalpath=($k.$item.physicalpath).replace("/","\")
            $vanonymous=$k.$item.anonymous
            $vwindows=$k.$item.windows
            $vimpersonate=$k.$item.impersonate

                #lets load the website detials
                if($vwebsite.Length -ne 0){
                    ($j=$data.IISDeploy.Sites)|Where-Object{$_.name -eq $vwebsite}
                    
                    $site=$j.$vwebsite.Name
                    $port=$j.$vwebsite.port
                    $physicalpath=($j.$vwebsite.physicalpath).replace("/","\")
                    $anonymous=$j.$vwebsite.anonymous
                    $windows=$j.$vwebsite.windows
                   # $impersonate=$j.$vwebsite.impersonate
                    $apppool=$j.$vwebsite.apppool

                    Import-Module WebAdministration
                    #load the app-pool info from JSON
                    # validate app-pool name and initate the process for app-pool deployment
                if($Apppool.Length -ne 0){
                # load the app-pool information from JSON
                ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $Apppool}
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool=$i.$Apppool.Name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identity
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
            if(-not ([string]::IsNullOrWhiteSpace($pool))){
                #import module webadministration
                Import-Module webadministration
                #test the app-pool  exist or not . if exist then delete or set mesaage
                if(Test-Path IIS:\AppPools\$pool){
                    Write-Warning "The given App-pool:$pool already exist. Hence removing"
                    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                }
                else {
                    Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                } 
                
                #create new webapppool
                New-WebAppPool -Name $pool -Force
                #load the above created app-pool into local varaible
                $result=Get-Item IIS:\AppPools\$pool -Force
            
                #validate managed runtime version
                if(-not([string]::IsNullOrWhiteSpace($version))){
                    if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                        $result.managedRuntimeversion=$version
                    }
                    elseif($version -eq "No Managed Code"){
                        $result.managedRuntimeversion=""
                    }
                    else{
                        Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message " version should not be empty" -ErrorAction Stop
                }
            
                #validate managed pipeline mode
                if(-not([string]::IsNullOrWhiteSpace($mode))){
                    if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                        $result.ManagedPipelineMode=$mode
                    }
                    else {
                        Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                }
                #validate queuelength
                if(-not([string]::IsNullOrWhiteSpace($queuelength))){
                    if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                        $result.queuelength=[convert]::ToInt64($queuelength)
                    }
                    else {
                        Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                    }
                }
                else {
                    Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                }
                #validate enable32bit
                if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
                    if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                        $result.enable32BitAppOnWin64=$enable32bit
                    }
                    else {
                        Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                }
            
                #validate identity
                if(-not ([string]::IsNullOrWhiteSpace($identity))){
                    if($identity -eq "LocalSystem"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "LocalService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "NetworkService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "SpecificUser"){
                        $computer=$env:COMPUTERNAME
                        Add-type -AssemblyName system.directoryservices.AccountManagement
                        $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                        $credstatus=$creds.ValidateCredentials($user, $password)
                        if($credstatus -eq "true"){
                            $result.processModel.identityType="SpecificUser"
                            $result.processModel.userName=$user
                            $result.processModel.password=$password
                        }
                        else {
                            Write-Error -Message "Invalid credentials" -ErrorAction Stop
                        }
                    }
                    else{
                        Write-Warning "No matching identitytype found .hence applying default" 
                        $result.Processmodel.identitytype="ApplicationPoolIdentity"
                    }
                }
                else{
                    Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                }
            
                $result |Set-Item -Force -Verbose
            }# end of main if pool
            else{
                Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
            }
            
                }
                else{
                Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                }
                Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                ###########################################################################################################
				
				#website deployment begin
                Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                    if($site.lengh -ne 0){
                        if(Test-path IIS:\Sites\$site){
                            Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                        }
                        else{
                            Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                            #validate physicalpath
                            if(Test-Path $physicalpath\$site){
                                Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                                Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                            }
                            else{
                                    Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                            }
                            New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                            #validate port
                            if(($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)){
                                #create website
                                New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                            }
                            else{
                                Write-Error -Message "Port value must be set" -ErrorAction Stop
                            }

                            # apply Anonymous authentication
                            if($anonymous.length -ne 0){
                                if("$anonymous" -eq "True" -or "$anonymous" -eq "false"){
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else{
                                    Write-Warning "Invalid input provided . value must be true or false"
                                }
                            # apply windows authentication
                            if($windows.length -ne 0){
                                if($windows -eq "windows"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "basic"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "digest"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else{
                                    Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                }
                
                                }
                                else {
                                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                                }

                }
                else{
                    Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                }
                        }# end of test-path (else condtion)
                    }
                    else {
                        Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                    }
                Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green

                }# if $vwebsite
                else {
                    Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
                }
				###############################################################################################################################
				

                #lets start virtual site deployment
                Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
                if($vsite.Length -ne 0){
                    if(Test-Path IIS:\Sites\$site\$vsite){
                        Write-Warning "Given Virtual site already exist. Hence deleting"
                        Remove-Item IIS:\Sites\$site\$vsite -Force -Recurse -Verbose
                    }
                    else {
                        Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                    }
                    #validate physicalpath
                    if($vphysicalpath.Length -ne 0){
                        if(Test-path $vphysicalpath\$site\$vsite){
                            Write-Warning "physicalpath already exist. Hence deleting"
                            Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                        }
                        else{
                            Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                        }

                        New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                        
                    }
                    else {
                        Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                    }
                    #create virtualsite
                    New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop

                    #authentication
                    #anonymous
                    if($vanonymous.lengh -ne 0){
                        if("$vanonymous" -eq "True" -or "$vanonymous" -eq "False"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        else {
                            Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                        }
                    
                    }
                    else {
                        Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                    }
                    #windows
                    if($vwindows.Length -ne 0){
                        if($windows -eq "windows"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        elseif($windows -eq "basic"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        }
                        else{
                            Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                        }
                    }
                    else {
                        Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                    }
                    #Aspimpersonation
                    if($vimpersonate.Length -ne 0){
                        if($vimpersonate -eq "True"){
                            cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                        }
                        else {
                            cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                        }
                    }
                    else{
                        Write-Warning "Impersonate value must true or false" 
                    }

                }# end main if ($vsite.length)
                else {
                    Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
                }
                Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green

    }# end of foreach of vistes
}# end of $vsites.lengh main block
else {
    Write-Error -Message "Vsites should not be zero. Hence abort the process" -ErrorAction Stop
}
}
}
else {
    Write-Host "Components should not be empty" -ErrorAction Stop 
}

<json>

{
    "IISDeploy":{
        "AppPools":[
            {"VENKAT":{"Name":"Venkat","mode":"Integrated","version":"v4.0","queuelength":12345,"enable32bit":false,"identity":"SpecificUser","user":"vg","password":"Apple@1234"}}
        ],
        "Sites":[
            {"Aviva":{"Name":"Aviva","port":89,"physicalpath":"F:/azure/IIS/Sites","Apppool":"VENKAT","Anonymous":false,"windows":"windowsbasic","impersonate":true }},
            {"VG":{"Name":"EMC2","port":91,"physicalpath":"F:/azure/IIS/Sites","Apppool":"VENKAT","Anonymous":false,"windows":"windowsbasic","impersonate":true }},
            {"Apple":{"Name":"Apple","port":92,"physicalpath":"F:/azure/IIS/Sites","Apppool":"VENKAT","Anonymous":false,"windows":"windowsbasic","impersonate":true }}
        ],
        "Vsites":[
            {"H1":{"Name":"HCL","Site":"VG","physicalpath":"F:/azure/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"H2":{"Name":"ABC","Site":"VG","physicalpath":"F:/azure/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"H3":{"Name":"PQR","Site":"VG","physicalpath":"F:/azure/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"H4":{"Name":"RAJ","Site":"Apple","physicalpath":"F:/azure/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"H5":{"Name":"F5","Site":"Apple","physicalpath":"F:/azure/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}}
        ]
    } 
}


----------------
21/05/2020

$data = Get-Content H:\AZURE\POWERSHELL\NVSites.json | ConvertFrom-Json
#create empty array
$nvsites = @()
#load vsites from json into empty array
($data.IISDeploy.nvsites).ForEach{
    $nvsites += $_.psobject.properties.name
}

If ($nvsites.Length -ne 0) {
    foreach ($item in $nvsites) {
        Write-Host " Data reading process begin for Nested site :$item" -ForegroundColor Green
        ($a = $data.IISDeploy.nvsites) | Where-Object { $_.Name -eq $item }
        
        $nvsite = $a.$item.Name
        $virsite = $a.$item.Site
        $nvphysicalpath = ($a.$item.physicalpath).replace("/", "\")
        $nvanonymous = $a.$item.anonymous
        $nvwindows = $a.$item.windows
        $nvimpersonate = $a.$item.impersonate
        #valiate virtualsites lenght
        if ($virsite.Length -ne 0) {
            Write-Host " Data reading process begin for virtual site :$virsite" -ForegroundColor Green
            ($b = $data.IISDeploy.Vsites) | Where-Object { $_.Name -eq $virsite }

            $vsite = $b.$virsite.Name
            $website = $b.$virsite.Site 
            $vphysicalpath = ($b.$virsite.physicalpath).replace("/", "\")
            $vanonymous = $b.$virsite.anonymous
            $vwindows = $b.$virsite.windows
            $vimpersonate = $b.$virsite.impersonate

            #lets load the website detials
            if ($website.Length -ne 0) {
                ($c = $data.IISDeploy.Sites) | Where-Object { $_.name -eq $website }
                    
                $site = $c.$website.Name
                $port = $c.$website.port
                $physicalpath = ($c.$website.physicalpath).replace("/", "\")
                $anonymous = $c.$website.anonymous
                $windows = $c.$website.windows
                $impersonate=$c.$website.impersonate
                $Apppool = $c.$website.apppool

                
                #load the app-pool info from JSON
                # validate app-pool name and initate the process for app-pool deployment
                if ($Apppool.Length -ne 0) {
                    # load the app-pool information from JSON
                    ($d = $Data.IISDeploy.AppPools) | Where-Object { $_.Name -eq $Apppool }
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool = $d.$Apppool.Name
                    $version = $d.$Apppool.version
                    $mode = $d.$Apppool.mode
                    $queuelength = $d.$Apppool.queuelength
                    $enable32bit = $d.$Apppool.enable32bit
                    $identity = $d.$Apppool.identity
                    $user = $d.$Apppool.user
                    $password = $d.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                    if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                        #import module webadministration
                        Import-Module webadministration
                        #test the app-pool  exist or not . if exist then delete or set mesaage
                        if (Test-Path IIS:\AppPools\$pool) {
                            Write-Warning "The given App-pool:$pool already exist. Hence removing"
                            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                        } 
                
                        #create new webapppool
                        New-WebAppPool -Name $pool -Force
                        #load the above created app-pool into local varaible
                        $result = Get-Item IIS:\AppPools\$pool -Force
            
                        #validate managed runtime version
                        if (-not([string]::IsNullOrWhiteSpace($version))) {
                            if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                $result.managedRuntimeversion = $version
                            }
                            elseif ($version -eq "No Managed Code") {
                                $result.managedRuntimeversion = ""
                            }
                            else {
                                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message " version should not be empty" -ErrorAction Stop
                        }
            
                        #validate managed pipeline mode
                        if (-not([string]::IsNullOrWhiteSpace($mode))) {
                            if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                $result.ManagedPipelineMode = $mode
                            }
                            else {
                                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                        }
                        #validate queuelength
                        if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                            if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                $result.queuelength = [convert]::ToInt64($queuelength)
                            }
                            else {
                                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                            }
                        }
                        else {
                            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                        }
                        #validate enable32bit
                        if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                            if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                $result.enable32BitAppOnWin64 = $enable32bit
                            }
                            else {
                                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                        }
            
                        #validate identity
                        if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                            if ($identity -eq "LocalSystem") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "LocalService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "NetworkService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "SpecificUser") {
                                $computer = $env:COMPUTERNAME
                                Add-type -AssemblyName system.directoryservices.AccountManagement
                                $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                $credstatus = $creds.ValidateCredentials($user, $password)
                                if ($credstatus -eq "true") {
                                    $result.processModel.identityType = "SpecificUser"
                                    $result.processModel.userName = $user
                                    $result.processModel.password = $password
                                }
                                else {
                                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Warning "No matching identitytype found .hence applying default" 
                                $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                            }
                        }
                        else {
                            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                        }
            
                        $result | Set-Item -Force -Verbose
                    }# end of main if pool
                    else {
                        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                }
                Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                
                #######################################################################################################################
                #website deployment begin
                Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                if ($site.length -ne 0) {
                    if (Test-path IIS:\Sites\$site) {
                        Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                    }
                    else {
                        Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                        #validate physicalpath
                        if (Test-Path $physicalpath\$site) {
                            Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                            Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                        }
                        New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                        #validate port
                        if (($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)) {
                            #create website
                            New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                        }
                        else {
                            Write-Error -Message "Port value must be set" -ErrorAction Stop
                        }

                        # apply Anonymous authentication
                        if ($anonymous.length -ne 0) {
                            if ("$anonymous" -eq "True" -or "$anonymous" -eq "false") {
                                Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                            }
                            else {
                                Write-Warning "Invalid input provided . value must be true or false"
                            }
                            # apply windows authentication
                            if ($windows.length -ne 0) {
                                if ($windows -eq "windows") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "basic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "digest") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else {
                                    Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                }
                
                            }
                            else {
                                Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                            }

                        }
                        else {
                            Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                        }
                    }# end of test-path (else condtion)
                }
                else {
                    Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                }
                Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green

            }# if $vwebsite
            else {
                Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
            }
            ###########################################################################################################
            #lets start virtual site deployment
            Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
            if ($vsite.Length -ne 0) {
                if (Test-Path IIS:\Sites\$site\$vsite) {
                    Write-Warning "Given Virtual site already exist. Hence deleting"
                    Remove-Item IIS:\Sites\$site\$vsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                }
                #validate physicalpath
                if ($vphysicalpath.Length -ne 0) {
                    if (Test-path $vphysicalpath\$site\$vsite) {
                        Write-Warning "physicalpath already exist. Hence deleting"
                        Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                    }
                    else {
                        Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                    }

                    New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                        
                }
                else {
                    Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                }
                #create virtualsite
                New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop

                #authentication
                #anonymous
                if ($vanonymous.length -ne 0) {
                    if ("$vanonymous" -eq "True" -or "$vanonymous" -eq "False") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                    }
                    
                }
                else {
                    Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                }
                #windows
                if ($vwindows.Length -ne 0) {
                    if ($vwindows -eq "windows") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    } 
                    elseif ($vwindows -eq "basic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    elseif ($vwindows -eq "windowsbasic" -or $vwindows -eq "windowsandbasic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                    }
                }
                else {
                    Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                }
                #Aspimpersonation
                Write-Host "#############################"
                if ($vimpersonate.Length -ne 0) {
                    if ($vimpersonate -eq "true") {##################
                        cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                    }
                    else {
                        cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                    }
                }
                else {
                    Write-Warning "Impersonate value must true or false" 
                }
                Write-Host "#############################"
            }# end main if ($vsite.length)
            else {
                Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
            }
            Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green 

        
        }# end of $vsites.length main block
        else {
            Write-Error -Message "Vsites should not be zero. Hence abort the process" -ErrorAction Stop
        }
        ##############################################################################################
        #lets start Nested site deployment
        Write-Host "*********************************[Begin] NestedVirtual site: $nvsite deployment***************************" -ForegroundColor Green
        if ($nvsite.Length -ne 0) {
            # Creating variable to get physical Path 
            #$targetpath="$nvphysicalpath\$site\$vsite\$nvsite"
            if (Test-Path IIS:\Sites\$site\$vsite\$nvsite) {
                Write-Warning "Given NestedVirtual site already exist. Hence deleting"
                Remove-Item IIS:\Sites\$site\$vsite\$nvsite -Force -Recurse -Verbose
            }
            else {
                Write-Host "No NestedVirtual site found with name :$nvsite. Hence creating new" -ForegroundColor Cyan
            }
            #validate physicalpath
            if ($nvphysicalpath.Length -ne 0) {
                if (Test-path $nvphysicalpath\$site\$vsite\$nvsite) {
                    Write-Warning "physicalpath already exist $nvphysicalpath\$site\$vsite\$nvsite. Hence deleting"
                    Remove-Item $nvphysicalpath\$site\$vsite\$nvsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No path found with $nvphysicalpath\$site\$vsite\$nvsite .hence creating new" -ForegroundColor Cyan
                }

                New-Item $nvphysicalpath\$site\$vsite\$nvsite -ItemType Directory -Force
                        
            }
            else {
                Write-Error -Message "Physicalpath on nested must be set" -ErrorAction Stop
            }
            #create virtualsite
            New-WebApplication -Name $nvsite -Site $site\$vsite -PhysicalPath $nvphysicalpath\$site\$vsite\$nvsite -ApplicationPool $pool -Force -ErrorAction Stop

            #authentication
            #anonymous
            if ($nvanonymous.lengh -ne 0) {
                if ("$nvanonymous" -eq "True" -or "$nvanonymous" -eq "False") {
                    Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $nvanonymous -PSPath IIS:\Sites\$site\$vsite -Location $nvsite -ErrorAction Stop
                }
                else {
                    Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                }
                    
            }
            else {
                Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
            }
            #windows
            if ($nvwindows.Length -ne 0) {
                if ($nvwindows -eq "windows") {
                    Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site\$vsite -Location $nvsite -ErrorAction Stop
                }
                elseif ($nvwindows -eq "basic") {
                    Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site\$vsite -Location $nvsite -ErrorAction Stop
                }
                elseif ($nvwindows -eq "windowsbasic" -or $nvwindows -eq "windowsandbasic") {
                    Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site\$vsite -Location $nvsite -ErrorAction Stop
                    Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site\$vsite -Location $nvsite -ErrorAction Stop
                }
                else {
                    Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                }
            }
            else {
                Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
            }
            #Aspimpersonation
            if ($nvimpersonate.Length -ne 0) {
                if ($nvimpersonate -eq "True") {
                    cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite/$nvsite /section:system.web/identity /impersonate:true"
                }
                else {
                    cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite/$nvsite /section:system.web/identity /impersonate:false"
                }
            }
            else {
                Write-Warning "Impersonate value must true or false" 
            }

        }# end main if ($nvsite.length)
        else {
            Write-Error -Message "NestedVirtual site name must be set" -ErrorAction Stop
        }
        Write-Host "*********************************[End] Virtual site: $nvsite deployment***************************" -ForegroundColor Green
    }
}# end of foreach of vistes
else {
    Write-Host "The nested site should not be empty" -ErrorAction Stop
}

<JSON>

{
    "IISDeploy":{
        "AppPools":[
            {"RAJA":{"Name":"RAJA","mode":"Integrated","version":"v4.0","queuelength":6666,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"CTS":{"Name":"CTS","port":89,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"RAJA","Anonymous":false,"windows":"windowsbasic","impersonate":true }},
            {"GL":{"Name":"GL","port":91,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"RAJA","Anonymous":false,"windows":"windowsbasic","impersonate":true }}
            
        ],
        "Vsites":[
            {"L&T":{"Name":"L&T","Site":"CTS","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}},
            {"F5":{"Name":"F5","Site":"GL","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":false}}
        ],
        "nvsites":[
            {"WIPRO":{"Name":"WIPRO","Site":"F5","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":false}},
            {"INFOSYS":{"Name":"INFOSYS","Site":"L&T","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":false,"windows":"windows","impersonate":true}}
            
        ]    
    } 
}

----------------------------
22/05/2020


$Data = Get-Content H:\AZURE\POWERSHELL\Allsiteconfig.json | ConvertFrom-Json
#declare empty array to load nvsites information
$nvsites = @()
($data.IISDeploy.nvsites).ForEach{
    $nvsites += $_.psobject.properties.name
}

#declare empty array for virtual sites
$vsites = @()
($data.IISDeploy.Vsites).ForEach{
    $vsites += $_.psobject.properties.Name
}

#declare empty array for sites
$sites = @()
($data.IISDeploy.Sites).ForEach{
    $sites += $_.psobject.properties.Name
}
#validate length of nvistes default it should not be zero
    if ($nvsites.Length -ne 0) {
        foreach ($item in $nvsites) {
            Write-host "Getting details of $item from JSON" -ForegroundColor Cyan
            ($l = $Data.IISDeploy.nvsites) | Where-Object { $_.Name -eq $item }
            $nVsite = $l.$item.Name
            $virtualsite = $l.$item.site
            $nPhysicalpath = ($l.$item.physicalpath).replace("/", "\")
            $nAnonymous = $l.$item.Anonymous
            $nWindows = $l.$item.windows
            $nImpersonate = $l.$item.impersonate
            
            #validate virtualsite length
            if ($virtualsite.Length -ne 0) {
                Write-Host " Data reading process begin for virtual site :$virtualsite" -ForegroundColor Green
                ($k = $data.IISDeploy.Vsites) | Where-Object { $_.Name -eq $virtualsite }
            
                $vsite = $k.$virtualsite.Name
                $vwebsite = $k.$virtualsite.site
                $vphysicalpath = ($k.$virtualsite.physicalpath).replace("/", "\")
                $vanonymous = $k.$virtualsite.anonymous
                $vwindows = $k.$virtualsite.windows
                $vimpersonate = $k.$virtualsite.impersonate
            
                #lets load the website detials
                if ($vwebsite.Length -ne 0) {
                    ($j = $data.IISDeploy.Sites) | Where-Object { $_.name -eq $vwebsite }
                                
                    $site = $j.$vwebsite.Name
                    $port = $j.$vwebsite.port
                    $physicalpath = ($j.$vwebsite.physicalpath).replace("/", "\")
                    $anonymous = $j.$vwebsite.anonymous
                    $windows = $j.$vwebsite.windows
                    $impersonate = $j.$vwebsite.impersonate
                    $apppool = $j.$vwebsite.apppool
            
                    Import-Module WebAdministration
                    #load the app-pool info from JSON
                    # validate app-pool name and initate the process for app-pool deployment
                    if ($Apppool.Length -ne 0) {
                        # load the app-pool information from JSON
                        ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.Name -eq $Apppool }
                            
                        Write-Host "Working on App-pool :$item" -ForegroundColor Green
                        # load the variables from json for specific app-pool
                                
                        $pool = $i.$Apppool.Name
                        $version = $i.$Apppool.version
                        $mode = $i.$Apppool.mode
                        $queuelength = $i.$Apppool.queuelength
                        $enable32bit = $i.$Apppool.enable32bit
                        $identity = $i.$Apppool.identity
                        $user = $i.$Apppool.user
                        $password = $i.$Apppool.password
                        
                        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                        if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                            #import module webadministration
                            Import-Module webadministration
                            #test the app-pool  exist or not . if exist then delete or set mesaage
                            if (Test-Path IIS:\AppPools\$pool) {
                                Write-Warning "The given App-pool:$pool already exist. Hence removing"
                                Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                            }
                            else {
                                Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                            } 
                            
                            #create new webapppool
                            New-WebAppPool -Name $pool -Force
                            #load the above created app-pool into local varaible
                            $result = Get-Item IIS:\AppPools\$pool -Force
                        
                            #validate managed runtime version
                            if (-not([string]::IsNullOrWhiteSpace($version))) {
                                if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                    $result.managedRuntimeversion = $version
                                }
                                elseif ($version -eq "No Managed Code") {
                                    $result.managedRuntimeversion = ""
                                }
                                else {
                                    Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message " version should not be empty" -ErrorAction Stop
                            }
                        
                            #validate managed pipeline mode
                            if (-not([string]::IsNullOrWhiteSpace($mode))) {
                                if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                    $result.ManagedPipelineMode = $mode
                                }
                                else {
                                    Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                            }
                            #validate queuelength
                            if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                                if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                    $result.queuelength = [convert]::ToInt64($queuelength)
                                }
                                else {
                                    Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                                }
                            }
                            else {
                                Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                            }
                            #validate enable32bit
                            if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                                if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                    $result.enable32BitAppOnWin64 = $enable32bit
                                }
                                else {
                                    Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                            }
                        
                            #validate identity
                            if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                                if ($identity -eq "LocalSystem") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "LocalService") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "NetworkService") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "SpecificUser") {
                                    $computer = $env:COMPUTERNAME
                                    Add-type -AssemblyName system.directoryservices.AccountManagement
                                    $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                    $credstatus = $creds.ValidateCredentials($user, $password)
                                    if ($credstatus -eq "true") {
                                        $result.processModel.identityType = "SpecificUser"
                                        $result.processModel.userName = $user
                                        $result.processModel.password = $password
                                    }
                                    else {
                                        Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                    }
                                }
                                else {
                                    Write-Warning "No matching identitytype found .hence applying default" 
                                    $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                                }
                            }
                            else {
                                Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                            }
                        
                            $result | Set-Item -Force -Verbose
                        }# end of main if pool
                        else {
                            Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                        }
                        
                            
                    }
                    else {
                        Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                    }
                    Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                    #website deployment begin
                    Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                    if ($site.lengh -ne 0) {
                        if (Test-path IIS:\Sites\$site) {
                            Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                        }
                        else {
                            Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                            #validate physicalpath
                            if (Test-Path $physicalpath\$site) {
                                Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                                Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                            }
                            else {
                                Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                            }
                            New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                            #validate port
                            if (($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)) {
                                #create website
                                New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                            }
                            else {
                                Write-Error -Message "Port value must be set" -ErrorAction Stop
                            }
            
                            # apply Anonymous authentication
                            if ($anonymous.length -ne 0) {
                                if ("$anonymous" -eq "True" -or "$anonymous" -eq "false") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else {
                                    Write-Warning "Invalid input provided . value must be true or false"
                                }
                                # apply windows authentication
                                if ($windows.length -ne 0) {
                                    if ($windows -eq "windows") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "basic") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "digest") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    else {
                                        Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                    }
                            
                                }
                                else {
                                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                                }
            
                            }
                            else {
                                Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                            }
                        }# end of test-path (else condtion)
                    }
                    else {
                        Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                    }
                    Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green
            
                }# if $vwebsite
                else {
                    Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
                }
            
                #lets start virtual site deployment
                Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
                if ($vsite.Length -ne 0) {
                    if (Test-Path IIS:\Sites\$site\$vsite) {
                        Write-Warning "Given Virtual site already exist. Hence moving to nested virtual site deployment"
                    }
                    else {
                        Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                        #validate physicalpath
                        if ($vphysicalpath.Length -ne 0) {
                            if (Test-path $vphysicalpath\$site\$vsite) {
                                Write-Warning "physicalpath already exist. Hence deleting"
                                Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                            }
                            else {
                                Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                            }
            
                            New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                                    
                        }
                        else {
                            Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                        }
                        #create virtualsite
                        New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop
            
                        #authentication
                        #anonymous
                        if ($vanonymous.lengh -ne 0) {
                            if ("$vanonymous" -eq "True" -or "$vanonymous" -eq "False") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            else {
                                Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                            }
                                
                        }
                        else {
                            Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                        }
                        #windows
                        if ($vwindows.Length -ne 0) {
                            if ($windows -eq "windows") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            elseif ($windows -eq "basic") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            else {
                                Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                            }
                        }
                        else {
                            Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                        }
                        #Aspimpersonation
                        if ($vimpersonate.Length -ne 0) {
                            if ($vimpersonate -eq "True") {
                                cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                            }
                            else {
                                cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                            }
                        }
                        else {
                            Write-Warning "Impersonate value must true or false" 
                        }

                    }
                }# end main if ($vsite.length)
                else {
                    Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
                }
                Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green
            
                
            }
            else {
                Write-Error -Message "Virtualsite length should not be zero. hecne process aborted" -ErrorAction Stop
            }

            #validate nested virtual site deployment
            if ($nvsite.Length -ne 0) {
                #creating varaible to get actual physicalpath
                $targetpath = "$nPhysicalpath\$site\$vsite\$nvsite"
                if (Test-Path IIS:\Sites\$site\$vsite\$nVsite) {
                    Write-Warning " The following[$nVsite] nested virtual site already exist. Hence deleting"
                    Remove-Item IIS:\Sites\$site\$vsite\$nVsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No nested virtual site found with [$nVsite]. Hence creating new" -ForegroundColor Green
                }

                #validate physicalpath
                if ($targetpath.Length -ne 0) {
                    if (Test-path $targetpath) {
                        write-warning " physicalpath found [$Targetpath] .hence deleting"
                        remove-item $Targetpath -force -recurse
                    }
                    else {
                        Write-host "No physicalpath found with [$Targetpath] .hence creating new"
                    }
                    New-item $Targetpath -itemtype Directory -force
                }
                else {
                    Write-Error -Message "Physicalpath should not be empty. Process aborted" -ErrorAction Stop
                }
                # create neted virtual site
                new-webapplication -name $nVsite -site "$site/$vsite" -physicalpath $Targetpath -applicationpool $pool -force -ErrorAction stop
            }# end of $nvsite.length main block
            else {
                Write-Error -Message " nested virtualsite name :$vnsite must be set. hence Process aborted" -ErrorAction Stop
            }
        }# end of foreach
    }# end of $nvistes.length
    elseif (($nvsites.Length -eq 0) -and ($vsites.Length -ne 0)) {
        foreach ($item in $vsites) {
            Write-Host " Data reading process begin for virtual site :$item" -ForegroundColor Green
            ($k = $data.IISDeploy.Vsites) | Where-Object { $_.Name -eq $item }

            $vsite = $k.$item.Name
            $vwebsite = $k.$item.site
            $vphysicalpath = ($k.$item.physicalpath).replace("/", "\")
            $vanonymous = $k.$item.anonymous
            $vwindows = $k.$item.windows
            $vimpersonate = $k.$item.impersonate

            #lets load the website detials
            if ($vwebsite.Length -ne 0) {
                ($j = $data.IISDeploy.Sites) | Where-Object { $_.name -eq $vwebsite }
                    
                $site = $j.$vwebsite.Name
                $port = $j.$vwebsite.port
                $physicalpath = ($j.$vwebsite.physicalpath).replace("/", "\")
                $anonymous = $j.$vwebsite.anonymous
                $windows = $j.$vwebsite.windows
                $impersonate = $j.$vwebsite.impersonate
                $apppool = $j.$vwebsite.apppool

                Import-Module WebAdministration
                #load the app-pool info from JSON
                # validate app-pool name and initate the process for app-pool deployment
                if ($Apppool.Length -ne 0) {
                    # load the app-pool information from JSON
                    ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.Name -eq $Apppool }
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool = $i.$Apppool.Name
                    $version = $i.$Apppool.version
                    $mode = $i.$Apppool.mode
                    $queuelength = $i.$Apppool.queuelength
                    $enable32bit = $i.$Apppool.enable32bit
                    $identity = $i.$Apppool.identity
                    $user = $i.$Apppool.user
                    $password = $i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                    if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                        #import module webadministration
                        Import-Module webadministration
                        #test the app-pool  exist or not . if exist then delete or set mesaage
                        if (Test-Path IIS:\AppPools\$pool) {
                            Write-Warning "The given App-pool:$pool already exist. Hence removing"
                            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                        } 
                
                        #create new webapppool
                        New-WebAppPool -Name $pool -Force
                        #load the above created app-pool into local varaible
                        $result = Get-Item IIS:\AppPools\$pool -Force
            
                        #validate managed runtime version
                        if (-not([string]::IsNullOrWhiteSpace($version))) {
                            if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                $result.managedRuntimeversion = $version
                            }
                            elseif ($version -eq "No Managed Code") {
                                $result.managedRuntimeversion = ""
                            }
                            else {
                                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message " version should not be empty" -ErrorAction Stop
                        }
            
                        #validate managed pipeline mode
                        if (-not([string]::IsNullOrWhiteSpace($mode))) {
                            if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                $result.ManagedPipelineMode = $mode
                            }
                            else {
                                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                        }
                        #validate queuelength
                        if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                            if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                $result.queuelength = [convert]::ToInt64($queuelength)
                            }
                            else {
                                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                            }
                        }
                        else {
                            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                        }
                        #validate enable32bit
                        if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                            if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                $result.enable32BitAppOnWin64 = $enable32bit
                            }
                            else {
                                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                        }
            
                        #validate identity
                        if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                            if ($identity -eq "LocalSystem") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "LocalService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "NetworkService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "SpecificUser") {
                                $computer = $env:COMPUTERNAME
                                Add-type -AssemblyName system.directoryservices.AccountManagement
                                $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                $credstatus = $creds.ValidateCredentials($user, $password)
                                if ($credstatus -eq "true") {
                                    $result.processModel.identityType = "SpecificUser"
                                    $result.processModel.userName = $user
                                    $result.processModel.password = $password
                                }
                                else {
                                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Warning "No matching identitytype found .hence applying default" 
                                $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                            }
                        }
                        else {
                            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                        }
            
                        $result | Set-Item -Force -Verbose
                    }# end of main if pool
                    else {
                        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                    }
            
                
                }
                else {
                    Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                }
                Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                #website deployment begin
                Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                if ($site.lengh -ne 0) {
                    if (Test-path IIS:\Sites\$site) {
                        Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                    }
                    else {
                        Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                        #validate physicalpath
                        if (Test-Path $physicalpath\$site) {
                            Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                            Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                        }
                        New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                        #validate port
                        if (($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)) {
                            #create website
                            New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                        }
                        else {
                            Write-Error -Message "Port value must be set" -ErrorAction Stop
                        }

                        # apply Anonymous authentication
                        if ($anonymous.length -ne 0) {
                            if ("$anonymous" -eq "True" -or "$anonymous" -eq "false") {
                                Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                            }
                            else {
                                Write-Warning "Invalid input provided . value must be true or false"
                            }
                            # apply windows authentication
                            if ($windows.length -ne 0) {
                                if ($windows -eq "windows") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "basic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "digest") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else {
                                    Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                }
                
                            }
                            else {
                                Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                            }

                        }
                        else {
                            Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                        }
                    }# end of test-path (else condtion)
                }
                else {
                    Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                }
                Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green

            }# if $vwebsite
            else {
                Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
            }

            #lets start virtual site deployment
            Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
            if ($vsite.Length -ne 0) {
                if (Test-Path IIS:\Sites\$site\$vsite) {
                    Write-Warning "Given Virtual site already exist. Hence deleting"
                    Remove-Item IIS:\Sites\$site\$vsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                }
                #validate physicalpath
                if ($vphysicalpath.Length -ne 0) {
                    if (Test-path $vphysicalpath\$site\$vsite) {
                        Write-Warning "physicalpath already exist. Hence deleting"
                        Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                    }
                    else {
                        Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                    }

                    New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                        
                }
                else {
                    Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                }
                #create virtualsite
                New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop

                #authentication
                #anonymous
                if ($vanonymous.lengh -ne 0) {
                    if ("$vanonymous" -eq "True" -or "$vanonymous" -eq "False") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                    }
                    
                }
                else {
                    Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                }
                #windows
                if ($vwindows.Length -ne 0) {
                    if ($windows -eq "windows") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    elseif ($windows -eq "basic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                    }
                }
                else {
                    Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                }
                #Aspimpersonation
                if ($vimpersonate.Length -ne 0) {
                    if ($vimpersonate -eq "True") {
                        cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                    }
                    else {
                        cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                    }
                }
                else {
                    Write-Warning "Impersonate value must true or false" 
                }

            }# end main if ($vsite.length)
            else {
                Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
            }
            Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green

        }# end of foreach of vistes
    }
    elseif (($nvsites.Length -eq 0) -and ($vsites.Length -eq 0)) {
        if ($sites.Length -ne 0) {
            foreach ($item in $sites) {
                Write-Host "Workign on website: $item" -ForegroundColor Green
                ($j = $Data.IISDeploy.Sites) | Where-Object { $_.Name -eq $item }
                $site = $j.$item.Name
                $port = $j.$item.port
                $physicalpath = ($j.$item.physicalpath).Replace("/", "\")
                $Apppool = $j.$item.Apppool
    
                if ($Apppool.Length -ne 0) {
                    Write-Host " Working on App-pool:$Apppool deployment" -ForegroundColor green
                    ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.name -eq $Apppool }
                    # load the variables from json for specific app-pool
                    $pool = $i.$Apppool.name
                    $version = $i.$Apppool.version
                    $mode = $i.$Apppool.mode
                    $queuelength = $i.$Apppool.queuelength
                    $enable32bit = $i.$Apppool.enable32bit
                    $identity = $i.$Apppool.identity
                    $user = $i.$Apppool.user
                    $password = $i.$Apppool.password
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                    if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                        #import module webadministration
                        Import-Module webadministration
                        #test the app-pool  exist or not . if exist then delete or set mesaage
                        if (Test-Path IIS:\AppPools\$pool) {
                            Write-Warning "The given App-pool:$pool already exist. Hence removing"
                            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                        } 
                        
                        #create new webapppool
                        New-WebAppPool -Name $pool -Force
                        #load the above created app-pool into local varaible
                        $result = Get-Item IIS:\AppPools\$pool -Force
                    
                        #validate managed runtime version
                        if (-not([string]::IsNullOrWhiteSpace($version))) {
                            if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                $result.managedRuntimeversion = $version
                            }
                            elseif ($version -eq "No Managed Code") {
                                $result.managedRuntimeversion = ""
                            }
                            else {
                                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message " version should not be empty" -ErrorAction Stop
                        }
                    
                        #validate managed pipeline mode
                        if (-not([string]::IsNullOrWhiteSpace($mode))) {
                            if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                $result.ManagedPipelineMode = $mode
                            }
                            else {
                                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                        }
                        #validate queuelength
                        if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                            if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                $result.queuelength = [convert]::ToInt64($queuelength)
                            }
                            else {
                                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                            }
                        }
                        else {
                            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                        }
                        #validate enable32bit
                        if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                            if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                $result.enable32BitAppOnWin64 = $enable32bit
                            }
                            else {
                                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                        }
                    
                        #validate identity
                        if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                            if ($identity -eq "LocalSystem") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "LocalService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "NetworkService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "SpecificUser") {
                                $computer = $env:COMPUTERNAME
                                Add-type -AssemblyName system.directoryservices.AccountManagement
                                $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                $credstatus = $creds.ValidateCredentials($user, $password)
                                if ($credstatus -eq "true") {
                                    $result.processModel.identityType = "SpecificUser"
                                    $result.processModel.userName = $user
                                    $result.processModel.password = $password
                                }
                                else {
                                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Warning "No matching identitytype found .hence applying default" 
                                $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                            }
                        }
                        else {
                            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                        }
                    
                        $result | Set-Item -Force -Verbose
                    }# end of main if pool
                    else {
                        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                    }
                    
                        
    
    
                }
                else {
                    Write-Error -Message "Pool name should not be empty. Hence aborting the process" -ErrorAction stop
                }
                #valite sitename should not be empty
                if ($site.Length -ne 0) {
                    #import the module webadministration
                    Import-Module WebAdministration
                    if (Test-Path IIS:\Sites\$site) {
                        Write-Warning " the given site : $site found .Hence deleting"
                        Remove-Item IIS:\Sites\$site -Force -Recurse -Verbose
                    }
                    else {
                        Write-Host "No site found with name of :$site. hence creating new" -ForegroundColor Green
                    }
    
                    #validate physicalpath 
                    if ($physicalpath.Length -ne 0) {
                        # test the physicalpath 
                        if (Test-path $physicalpath\$site) {
                            Write-Warning "Physicalpath :$physicalpath\$site already exist .hence Deleting"
                            Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "Physicalpath :$physicalpath\$site doesnot exit. Hence creating new" -ForegroundColor Green
                        }
                        #creating physicalpath
                        New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
    
                    }
                    else {
                        Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
                    } # end physicalpath condition
    
                    #validate port and create newwebsite
                    if ($port.length -ne 0) {
                        New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $pool -Force -ErrorAction Stop
                    }
                    else {
                        Write-Error "Port numbe should not be empty .hence aborting the process" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop
                }
                
            }
        }
        else {
            Write-Error -Message "No websites info found in JSON. hence process aborted" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "No nested virtual sites ,virtual sites ,sites found in JSON. Hecne process aborted" -ErrorAction Stop
    }


---------------------------
23/05/2020

#validate the package . if present then move to deploymnet or else break the deployment
        if($package.Length -ne 0){
            if(Test-Path $packagespath\$package.zip){
                Write-Host " Package $package Available in packages path " -ForegroundColor Green
                New-item "D:\temp-packages" -ItemType Directory -Force -ErrorAction Ignore
                if(Test-Path "D:\temp-packages\$package.zip"){
                    Write-Warning "Package already exist. hence deleting it"
                    Remove-Item D:\temp-packages\$package.zip -Force -Recurse -Verbose
                }
                else
                {
                    Write-Host "No package found . hence copying new" -ForegroundColor Cyan
                }
                Copy-item "$packagespath\$package.zip" -Destination "D:\temp-packages\$package.zip" -Force -Recurse -Verbose -ErrorAction Stop
            }
            else{
                Write-Error -Message "Package : $package doesnot found in packages path .hence aborting the deployment " -ErrorAction Stop
            }
        }
        
        
        
 # after physicalpath create then need to extract pacakge into target location of site/vsite/nvsite
 # extract pacakge into physcialpath
                Expand-Archive "D:\temp-packages\$package.zip" -DestinationPath $Targetpath -Force -Verbose



=======================>
23/05/2020

$packagespath="H:\AZURE\package"
$Data = Get-Content H:\AZURE\POWERSHELL\packagingsites.json | ConvertFrom-Json
#declare empty array to load nvsites information
$nvsites = @()
($data.IISDeploy.nvsites).ForEach{
    $nvsites += $_.psobject.properties.name
}

#declare empty array for virtual sites
$vsites = @()
($data.IISDeploy.Vsites).ForEach{
    $vsites += $_.psobject.properties.Name
}

#declare empty array for sites
$sites = @()
($data.IISDeploy.Sites).ForEach{
    $sites += $_.psobject.properties.Name
}
#validate length of nvistes default it should not be zero
    if ($nvsites.Length -ne 0) {
        foreach ($item in $nvsites) {
            Write-host "Getting details of $item from JSON" -ForegroundColor Cyan
            ($l = $Data.IISDeploy.nvsites) | Where-Object { $_.Name -eq $item }
            $nVsite = $l.$item.Name
            $virtualsite = $l.$item.site
            $nPhysicalpath = ($l.$item.physicalpath).replace("/", "\")
            $nAnonymous = $l.$item.Anonymous
            $nWindows = $l.$item.windows
            $nImpersonate = $l.$item.impersonate
            $package = $l.$item.packagename
            
            #validate the package . if present then move to deploymnet or else break the deployment
        if($package.Length -ne 0){
            if(Test-Path $packagespath\$package.zip){
                Write-Host " Package $package Available in packages path " -ForegroundColor Green
                New-item "H:\tpackage" -ItemType Directory -Force -ErrorAction Ignore
                if(Test-Path "H:\tpackage\$package.zip"){
                    Write-Warning "Package already exist. hence deleting it"
                    Remove-Item H:\tpackage\$package.zip -Force -Recurse -Verbose
                }
                else
                {
                    Write-Host "No package found . hence copying new" -ForegroundColor Cyan
                }
                Copy-item "$packagespath\$package.zip" -Destination "H:\tpackage\$package.zip" -Force -Recurse -Verbose -ErrorAction Stop
            }
            else{
                Wri te-Error -Message "Package : $package doesnot found in packages path .hence aborting the deployment " -ErrorAction Stop
            }
        }

            #validate virtualsite length
            if ($virtualsite.Length -ne 0) {
                Write-Host " Data reading process begin for virtual site :$virtualsite" -ForegroundColor Green
                ($k = $data.IISDeploy.Vsites) | Where-Object { $_.Name -eq $virtualsite }
            
                $vsite = $k.$virtualsite.Name
                $vwebsite = $k.$virtualsite.site
                $vphysicalpath = ($k.$virtualsite.physicalpath).replace("/", "\")
                $vanonymous = $k.$virtualsite.anonymous
                $vwindows = $k.$virtualsite.windows
                $vimpersonate = $k.$virtualsite.impersonate
            
                #lets load the website detials
                if ($vwebsite.Length -ne 0) {
                    ($j = $data.IISDeploy.Sites) | Where-Object { $_.name -eq $vwebsite }
                                
                    $site = $j.$vwebsite.Name
                    $port = $j.$vwebsite.port
                    $physicalpath = ($j.$vwebsite.physicalpath).replace("/", "\")
                    $anonymous = $j.$vwebsite.anonymous
                    $windows = $j.$vwebsite.windows
                    $impersonate = $j.$vwebsite.impersonate
                    $apppool = $j.$vwebsite.apppool
            
                    Import-Module WebAdministration
                    #load the app-pool info from JSON
                    # validate app-pool name and initate the process for app-pool deployment
                    if ($Apppool.Length -ne 0) {
                        # load the app-pool information from JSON
                        ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.Name -eq $Apppool }
                            
                        Write-Host "Working on App-pool :$item" -ForegroundColor Green
                        # load the variables from json for specific app-pool
                                
                        $pool = $i.$Apppool.Name
                        $version = $i.$Apppool.version
                        $mode = $i.$Apppool.mode
                        $queuelength = $i.$Apppool.queuelength
                        $enable32bit = $i.$Apppool.enable32bit
                        $identity = $i.$Apppool.identity
                        $user = $i.$Apppool.user
                        $password = $i.$Apppool.password
                        
                        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                        if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                            #import module webadministration
                            Import-Module webadministration
                            #test the app-pool  exist or not . if exist then delete or set mesaage
                            if (Test-Path IIS:\AppPools\$pool) {
                                Write-Warning "The given App-pool:$pool already exist. Hence removing"
                                Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                            }
                            else {
                                Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                            } 
                            
                            #create new webapppool
                            New-WebAppPool -Name $pool -Force
                            #load the above created app-pool into local varaible
                            $result = Get-Item IIS:\AppPools\$pool -Force
                        
                            #validate managed runtime version
                            if (-not([string]::IsNullOrWhiteSpace($version))) {
                                if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                    $result.managedRuntimeversion = $version
                                }
                                elseif ($version -eq "No Managed Code") {
                                    $result.managedRuntimeversion = ""
                                }
                                else {
                                    Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message " version should not be empty" -ErrorAction Stop
                            }
                        
                            #validate managed pipeline mode
                            if (-not([string]::IsNullOrWhiteSpace($mode))) {
                                if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                    $result.ManagedPipelineMode = $mode
                                }
                                else {
                                    Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                            }
                            #validate queuelength
                            if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                                if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                    $result.queuelength = [convert]::ToInt64($queuelength)
                                }
                                else {
                                    Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                                }
                            }
                            else {
                                Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                            }
                            #validate enable32bit
                            if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                                if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                    $result.enable32BitAppOnWin64 = $enable32bit
                                }
                                else {
                                    Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                            }
                        
                            #validate identity
                            if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                                if ($identity -eq "LocalSystem") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "LocalService") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "NetworkService") {
                                    $result.Processmodel.Identitytype = $identity
                                }
                                elseif ($identity -eq "SpecificUser") {
                                    $computer = $env:COMPUTERNAME
                                    Add-type -AssemblyName system.directoryservices.AccountManagement
                                    $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                    $credstatus = $creds.ValidateCredentials($user, $password)
                                    if ($credstatus -eq "true") {
                                        $result.processModel.identityType = "SpecificUser"
                                        $result.processModel.userName = $user
                                        $result.processModel.password = $password
                                    }
                                    else {
                                        Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                    }
                                }
                                else {
                                    Write-Warning "No matching identitytype found .hence applying default" 
                                    $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                                }
                            }
                            else {
                                Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                            }
                        
                            $result | Set-Item -Force -Verbose
                        }# end of main if pool
                        else {
                            Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                        }
                        
                            
                    }
                    else {
                        Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                    }
                    Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                    #website deployment begin
                    Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                    if ($site.lengh -ne 0) {
                        if (Test-path IIS:\Sites\$site) {
                            Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                        }
                        else {
                            Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                            #validate physicalpath
                            if (Test-Path $physicalpath\$site) {
                                Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                                Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                            }
                            else {
                                Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                            }
                            New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                            #validate port
                            if (($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)) {
                                #create website
                                New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                            }
                            else {
                                Write-Error -Message "Port value must be set" -ErrorAction Stop
                            }
            
                            # apply Anonymous authentication
                            if ($anonymous.length -ne 0) {
                                if ("$anonymous" -eq "True" -or "$anonymous" -eq "false") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else {
                                    Write-Warning "Invalid input provided . value must be true or false"
                                }
                                # apply windows authentication
                                if ($windows.length -ne 0) {
                                    if ($windows -eq "windows") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "basic") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "digest") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    }
                                    else {
                                        Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                    }
                            
                                }
                                else {
                                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                                }
            
                            }
                            else {
                                Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                            }
                        }# end of test-path (else condtion)
                    }
                    else {
                        Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                    }
                    Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green
            
                }# if $vwebsite
                else {
                    Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
                }
            
                #lets start virtual site deployment
                Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
                if ($vsite.Length -ne 0) {
                    if (Test-Path IIS:\Sites\$site\$vsite) {
                        Write-Warning "Given Virtual site already exist. Hence moving to nested virtual site deployment"
                    }
                    else {
                        Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                        #validate physicalpath
                        if ($vphysicalpath.Length -ne 0) {
                            if (Test-path $vphysicalpath\$site\$vsite) {
                                Write-Warning "physicalpath already exist. Hence deleting"
                                Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                            }
                            else {
                                Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                            }
            
                            New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                                    
                        }
                        else {
                            Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                        }
                        #create virtualsite
                        New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop
            
                        #authentication
                        #anonymous
                        if ($vanonymous.lengh -ne 0) {
                            if ("$vanonymous" -eq "True" -or "$vanonymous" -eq "False") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            else {
                                Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                            }
                                
                        }
                        else {
                            Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                        }
                        #windows
                        if ($vwindows.Length -ne 0) {
                            if ($windows -eq "windows") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            elseif ($windows -eq "basic") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                                Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                            }
                            else {
                                Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                            }
                        }
                        else {
                            Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                        }
                        #Aspimpersonation
                        if ($vimpersonate.Length -ne 0) {
                            if ($vimpersonate -eq "True") {
                                cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                            }
                            else {
                                cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                            }
                        }
                        else {
                            Write-Warning "Impersonate value must true or false" 
                        }

                    }
                }# end main if ($vsite.length)
                else {
                    Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
                }
                Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green
            
                
            }
            else {
                Write-Error -Message "Virtualsite length should not be zero. hecne process aborted" -ErrorAction Stop
            }

            #validate nested virtual site deployment
            if ($nvsite.Length -ne 0) {
                #creating varaible to get actual physicalpath
                $targetpath = "$nPhysicalpath\$site\$vsite\$nvsite"
                if (Test-Path IIS:\Sites\$site\$vsite\$nVsite) {
                    Write-Warning " The following[$nVsite] nested virtual site already exist. Hence deleting"
                    Remove-Item IIS:\Sites\$site\$vsite\$nVsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No nested virtual site found with [$nVsite]. Hence creating new" -ForegroundColor Green
                }

                #validate physicalpath
                if ($targetpath.Length -ne 0) {
                    if (Test-path $targetpath) {
                        write-warning " physicalpath found [$Targetpath] .hence deleting"
                        remove-item $Targetpath -force -recurse
                    }
                    else {
                        Write-host "No physicalpath found with [$Targetpath] .hence creating new"
                    }
                    New-item $Targetpath -itemtype Directory -force

                    # after physicalpath create then need to extract pacakge into target location of site/vsite/nvsite
                    # extract pacakge into physcialpath
                Expand-Archive "H:\tpackage\$package.zip" -DestinationPath $Targetpath -Force -Verbose
                }
                else {
                    Write-Error -Message "Physicalpath should not be empty. Process aborted" -ErrorAction Stop
                }
                # create neted virtual site
                new-webapplication -name $nVsite -site "$site/$vsite" -physicalpath $Targetpath -applicationpool $pool -force -ErrorAction stop
            }# end of $nvsite.length main block
            else {
                Write-Error -Message " nested virtualsite name :$vnsite must be set. hence Process aborted" -ErrorAction Stop
            }
        }# end of foreach
    }# end of $nvistes.length
    elseif (($nvsites.Length -eq 0) -and ($vsites.Length -ne 0)) {
        foreach ($item in $vsites) {
            Write-Host " Data reading process begin for virtual site :$item" -ForegroundColor Green
            ($k = $data.IISDeploy.Vsites) | Where-Object { $_.Name -eq $item }

            $vsite = $k.$item.Name
            $vwebsite = $k.$item.site
            $vphysicalpath = ($k.$item.physicalpath).replace("/", "\")
            $vanonymous = $k.$item.anonymous
            $vwindows = $k.$item.windows
            $vimpersonate = $k.$item.impersonate

            #lets load the website detials
            if ($vwebsite.Length -ne 0) {
                ($j = $data.IISDeploy.Sites) | Where-Object { $_.name -eq $vwebsite }
                    
                $site = $j.$vwebsite.Name
                $port = $j.$vwebsite.port
                $physicalpath = ($j.$vwebsite.physicalpath).replace("/", "\")
                $anonymous = $j.$vwebsite.anonymous
                $windows = $j.$vwebsite.windows
                $impersonate = $j.$vwebsite.impersonate
                $apppool = $j.$vwebsite.apppool

                Import-Module WebAdministration
                #load the app-pool info from JSON
                # validate app-pool name and initate the process for app-pool deployment
                if ($Apppool.Length -ne 0) {
                    # load the app-pool information from JSON
                    ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.Name -eq $Apppool }
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool = $i.$Apppool.Name
                    $version = $i.$Apppool.version
                    $mode = $i.$Apppool.mode
                    $queuelength = $i.$Apppool.queuelength
                    $enable32bit = $i.$Apppool.enable32bit
                    $identity = $i.$Apppool.identity
                    $user = $i.$Apppool.user
                    $password = $i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                    if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                        #import module webadministration
                        Import-Module webadministration
                        #test the app-pool  exist or not . if exist then delete or set mesaage
                        if (Test-Path IIS:\AppPools\$pool) {
                            Write-Warning "The given App-pool:$pool already exist. Hence removing"
                            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                        } 
                
                        #create new webapppool
                        New-WebAppPool -Name $pool -Force
                        #load the above created app-pool into local varaible
                        $result = Get-Item IIS:\AppPools\$pool -Force
            
                        #validate managed runtime version
                        if (-not([string]::IsNullOrWhiteSpace($version))) {
                            if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                $result.managedRuntimeversion = $version
                            }
                            elseif ($version -eq "No Managed Code") {
                                $result.managedRuntimeversion = ""
                            }
                            else {
                                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message " version should not be empty" -ErrorAction Stop
                        }
            
                        #validate managed pipeline mode
                        if (-not([string]::IsNullOrWhiteSpace($mode))) {
                            if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                $result.ManagedPipelineMode = $mode
                            }
                            else {
                                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                        }
                        #validate queuelength
                        if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                            if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                $result.queuelength = [convert]::ToInt64($queuelength)
                            }
                            else {
                                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                            }
                        }
                        else {
                            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                        }
                        #validate enable32bit
                        if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                            if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                $result.enable32BitAppOnWin64 = $enable32bit
                            }
                            else {
                                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                        }
            
                        #validate identity
                        if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                            if ($identity -eq "LocalSystem") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "LocalService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "NetworkService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "SpecificUser") {
                                $computer = $env:COMPUTERNAME
                                Add-type -AssemblyName system.directoryservices.AccountManagement
                                $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                $credstatus = $creds.ValidateCredentials($user, $password)
                                if ($credstatus -eq "true") {
                                    $result.processModel.identityType = "SpecificUser"
                                    $result.processModel.userName = $user
                                    $result.processModel.password = $password
                                }
                                else {
                                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Warning "No matching identitytype found .hence applying default" 
                                $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                            }
                        }
                        else {
                            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                        }
            
                        $result | Set-Item -Force -Verbose
                    }# end of main if pool
                    else {
                        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                    }
            
                
                }
                else {
                    Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
                }
                Write-Host "********************[END]App-pool $pool deployment****************** " -ForegroundColor Green
                #website deployment begin
                Write-Host "********************[Begin]website $site deployment****************** " -ForegroundColor Green
                if ($site.lengh -ne 0) {
                    if (Test-path IIS:\Sites\$site) {
                        Write-Warning "The given site $site already exist. hecne moving virtual site deployment"
                    }
                    else {
                        Write-Host " No site found with $site. hence creating new" -ForegroundColor Cyan
                        #validate physicalpath
                        if (Test-Path $physicalpath\$site) {
                            Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                            Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                        }
                        New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                        #validate port
                        if (($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)) {
                            #create website
                            New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                        }
                        else {
                            Write-Error -Message "Port value must be set" -ErrorAction Stop
                        }

                        # apply Anonymous authentication
                        if ($anonymous.length -ne 0) {
                            if ("$anonymous" -eq "True" -or "$anonymous" -eq "false") {
                                Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                            }
                            else {
                                Write-Warning "Invalid input provided . value must be true or false"
                            }
                            # apply windows authentication
                            if ($windows.length -ne 0) {
                                if ($windows -eq "windows") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "basic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "digest") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                    Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                                }
                                else {
                                    Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                                }
                
                            }
                            else {
                                Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                            }

                        }
                        else {
                            Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                        }
                    }# end of test-path (else condtion)
                }
                else {
                    Write-Error -Message "Site name must be set.Aborting the process" -ErrorAction Stop
                }
                Write-Host "********************[End]website $site deployment****************** " -ForegroundColor Green

            }# if $vwebsite
            else {
                Write-Error -Message "Website name must be set in JSON. hence aborting the process" -ErrorAction Stop
            }

            #lets start virtual site deployment
            Write-Host "*********************************[Begin] Virtual site: $vsite deployment***************************" -ForegroundColor Green
            if ($vsite.Length -ne 0) {
                if (Test-Path IIS:\Sites\$site\$vsite) {
                    Write-Warning "Given Virtual site already exist. Hence deleting"
                    Remove-Item IIS:\Sites\$site\$vsite -Force -Recurse -Verbose
                }
                else {
                    Write-Host "No Virtual site found with name :$vsite. Hence creating new" -ForegroundColor Cyan
                }
                #validate physicalpath
                if ($vphysicalpath.Length -ne 0) {
                    if (Test-path $vphysicalpath\$site\$vsite) {
                        Write-Warning "physicalpath already exist. Hence deleting"
                        Remove-Item $vphysicalpath\$site\$vsite -Force -Recurse
                    }
                    else {
                        Write-Host "No path found with $vphysicalpath\$site\$vsite .hence creating new" -ForegroundColor Cyan
                    }

                    New-Item $vphysicalpath\$site\$vsite -ItemType Directory -Force
                        
                }
                else {
                    Write-Error -Message "Physicalpath must be set" -ErrorAction Stop
                }
                #create virtualsite
                New-WebApplication -Name $vsite -Site $site -PhysicalPath $vphysicalpath\$site\$vsite -ApplicationPool $pool -Force -ErrorAction Stop

                #authentication
                #anonymous
                if ($vanonymous.lengh -ne 0) {
                    if ("$vanonymous" -eq "True" -or "$vanonymous" -eq "False") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/anonymousAuthentication -Name enabled -Value $vanonymous -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "Anonymous value must be true or false. Hence no changes applied"
                    }
                    
                }
                else {
                    Write-Error -Message "Anonymous vlaue must be set as TRUE|False" -ErrorAction Stop
                }
                #windows
                if ($vwindows.Length -ne 0) {
                    if ($windows -eq "windows") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    elseif ($windows -eq "basic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    elseif ($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic") {
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/windowsAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                        Set-WebConfigurationProperty -Filter system.webServer/security/authentication/basicAuthentication -Name enabled -Value $true -PSPath IIS:\Sites\$site -Location $vsite -ErrorAction Stop
                    }
                    else {
                        Write-Warning "windows authentication must be windows,basic windowsbasic or windowsandbasic .hence no changes applied" 
                    }
                }
                else {
                    Write-Error -Message "Windows authentication must be set like windows, basic, windowsbasic or windowsandbasic" -ErrorAction Stop
                }
                #Aspimpersonation
                if ($vimpersonate.Length -ne 0) {
                    if ($vimpersonate -eq "True") {
                        cmd /c  "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:true"
                    }
                    else {
                        cmd /c "c:\windows\system32\inetsrv\appcmd.exe set config $site/$vsite /section:system.web/identity /impersonate:false"
                    }
                }
                else {
                    Write-Warning "Impersonate value must true or false" 
                }

            }# end main if ($vsite.length)
            else {
                Write-Error -Message "Virtual site name must be set" -ErrorAction Stop
            }
            Write-Host "*********************************[End] Virtual site: $vsite deployment***************************" -ForegroundColor Green

        }# end of foreach of vistes
    }
    elseif (($nvsites.Length -eq 0) -and ($vsites.Length -eq 0)) {
        if ($sites.Length -ne 0) {
            foreach ($item in $sites) {
                Write-Host "Workign on website: $item" -ForegroundColor Green
                ($j = $Data.IISDeploy.Sites) | Where-Object { $_.Name -eq $item }
                $site = $j.$item.Name
                $port = $j.$item.port
                $physicalpath = ($j.$item.physicalpath).Replace("/", "\")
                $Apppool = $j.$item.Apppool
    
                if ($Apppool.Length -ne 0) {
                    Write-Host " Working on App-pool:$Apppool deployment" -ForegroundColor green
                    ($i = $Data.IISDeploy.AppPools) | Where-Object { $_.name -eq $Apppool }
                    # load the variables from json for specific app-pool
                    $pool = $i.$Apppool.name
                    $version = $i.$Apppool.version
                    $mode = $i.$Apppool.mode
                    $queuelength = $i.$Apppool.queuelength
                    $enable32bit = $i.$Apppool.enable32bit
                    $identity = $i.$Apppool.identity
                    $user = $i.$Apppool.user
                    $password = $i.$Apppool.password
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                    if (-not ([string]::IsNullOrWhiteSpace($pool))) {
                        #import module webadministration
                        Import-Module webadministration
                        #test the app-pool  exist or not . if exist then delete or set mesaage
                        if (Test-Path IIS:\AppPools\$pool) {
                            Write-Warning "The given App-pool:$pool already exist. Hence removing"
                            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                        } 
                        
                        #create new webapppool
                        New-WebAppPool -Name $pool -Force
                        #load the above created app-pool into local varaible
                        $result = Get-Item IIS:\AppPools\$pool -Force
                    
                        #validate managed runtime version
                        if (-not([string]::IsNullOrWhiteSpace($version))) {
                            if (($version -eq "v2.0") -or ($version -eq "v4.0")) {
                                $result.managedRuntimeversion = $version
                            }
                            elseif ($version -eq "No Managed Code") {
                                $result.managedRuntimeversion = ""
                            }
                            else {
                                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message " version should not be empty" -ErrorAction Stop
                        }
                    
                        #validate managed pipeline mode
                        if (-not([string]::IsNullOrWhiteSpace($mode))) {
                            if (($mode -eq "Integrated") -or ($mode -eq "Classic")) {
                                $result.ManagedPipelineMode = $mode
                            }
                            else {
                                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                        }
                        #validate queuelength
                        if (-not([string]::IsNullOrWhiteSpace($queuelength))) {
                            if (([convert]::ToInt64($queuelength) -ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)) {
                                $result.queuelength = [convert]::ToInt64($queuelength)
                            }
                            else {
                                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                            }
                        }
                        else {
                            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                        }
                        #validate enable32bit
                        if (-not([string]::IsNullOrWhiteSpace($enable32bit))) {
                            if (("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")) {
                                $result.enable32BitAppOnWin64 = $enable32bit
                            }
                            else {
                                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                            }
                        }
                        else {
                            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                        }
                    
                        #validate identity
                        if (-not ([string]::IsNullOrWhiteSpace($identity))) {
                            if ($identity -eq "LocalSystem") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "LocalService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "NetworkService") {
                                $result.Processmodel.Identitytype = $identity
                            }
                            elseif ($identity -eq "SpecificUser") {
                                $computer = $env:COMPUTERNAME
                                Add-type -AssemblyName system.directoryservices.AccountManagement
                                $creds = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                                $credstatus = $creds.ValidateCredentials($user, $password)
                                if ($credstatus -eq "true") {
                                    $result.processModel.identityType = "SpecificUser"
                                    $result.processModel.userName = $user
                                    $result.processModel.password = $password
                                }
                                else {
                                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                                }
                            }
                            else {
                                Write-Warning "No matching identitytype found .hence applying default" 
                                $result.Processmodel.identitytype = "ApplicationPoolIdentity"
                            }
                        }
                        else {
                            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                        }
                    
                        $result | Set-Item -Force -Verbose
                    }# end of main if pool
                    else {
                        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                    }
                    
                        
    
    
                }
                else {
                    Write-Error -Message "Pool name should not be empty. Hence aborting the process" -ErrorAction stop
                }
                #valite sitename should not be empty
                if ($site.Length -ne 0) {
                    #import the module webadministration
                    Import-Module WebAdministration
                    if (Test-Path IIS:\Sites\$site) {
                        Write-Warning " the given site : $site found .Hence deleting"
                        Remove-Item IIS:\Sites\$site -Force -Recurse -Verbose
                    }
                    else {
                        Write-Host "No site found with name of :$site. hence creating new" -ForegroundColor Green
                    }
    
                    #validate physicalpath 
                    if ($physicalpath.Length -ne 0) {
                        # test the physicalpath 
                        if (Test-path $physicalpath\$site) {
                            Write-Warning "Physicalpath :$physicalpath\$site already exist .hence Deleting"
                            Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                        }
                        else {
                            Write-Host "Physicalpath :$physicalpath\$site doesnot exit. Hence creating new" -ForegroundColor Green
                        }
                        #creating physicalpath
                        New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
    
                    }
                    else {
                        Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
                    } # end physicalpath condition
    
                    #validate port and create newwebsite
                    if ($port.length -ne 0) {
                        New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $pool -Force -ErrorAction Stop
                    }
                    else {
                        Write-Error "Port numbe should not be empty .hence aborting the process" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop
                }
                
            }
        }
        else {
            Write-Error -Message "No websites info found in JSON. hence process aborted" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "No nested virtual sites ,virtual sites ,sites found in JSON. Hecne process aborted" -ErrorAction Stop
    }
	
----------------------
<JSON>	
	
{
    "IISDeploy":{
        "AppPools":[
            {"RAJA":{"Name":"RAJA","mode":"Integrated","version":"v4.0","queuelength":6666,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"CTS":{"Name":"CTS","port":89,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"RAJA","Anonymous":true,"windows":"windowsbasic","impersonate":false }},
            {"GL":{"Name":"GL","port":91,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"RAJA","Anonymous":true,"windows":"windowsbasic","impersonate":false }}
            
        ],
        "Vsites":[
            {"GO":{"Name":"GO","Site":"CTS","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":true,"windows":"windows","impersonate":false}},
            {"F5":{"Name":"F5","Site":"GL","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":true,"windows":"windows","impersonate":false}}
        ],
        "nvsites":[
            {"WIPRO":{"Name":"WIPRO","Site":"F5","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":true,"windows":"windows","impersonate":false,"packagename":"law"}},
            {"INFOSYS":{"Name":"INFOSYS","Site":"GO","physicalpath":"H:/AZURE/IIS/Sites","Anonymous":true,"windows":"windows","impersonate":false,"packagename":"foodshop"}}
            
        ]    
    } 
}

-----------------------------------------------------------------------------------

#for Pipeline automate

param(

    [string]$Jsonpath, #D:\Devops\AZ-800\apppool.json
    [string]$components, # array object
    [string]$packagespath  #$packagespath="D:\devops\az-800\packages"

)
function IIS-Deploy {
    [cmdletbinding()]    
    param(
        [string]$Jsonpath, #D:\Devops\AZ-800\apppool.json
        [string]$components, # array object
        [string]$packagespath  #$packagespath="D:\devops\az-800\packages"

    )



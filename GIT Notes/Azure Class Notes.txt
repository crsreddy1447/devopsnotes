29/04/2020 WINDOWS POWERSHELL
Configure iis
$ Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename
Store theses value in variable $<variable name>
$iisfeatures=Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename 

foreach($item in $iisfeatures.featurename){Enable-WindowsOptionalFeature -FeatureName $item -Online -Verbose}

cmdlet
commands are built in the form of verb-noun format
$ get-command    to list all commands
$ import-module webadministration -Verbose
$ get-command -Module webadministration

TO CHECK OPEN RUN(win+R) and type " inetmgr "
-Force is for conformation
-Verbose 

WIN ISE
Import-Module WebAdministration
New-WebAppPool -Name "RAJA" -Force   # To create a AppPools user 
$result=Get-Item IIS:\AppPools\RAJA -Force # To store appPool data to result 
$result |Format-List *                 # TO list the values stored in value
$result.managedPipelineMode="Classic"  # to change the parameter
$result.enable32BitAppOnWin64=$true  #for boolean true or false denote as a variable $true
$result.queueLength=65535
$result|Set-Item -Force -verbose       # to load the parameter in IIS

30/04/2020
Same as above with comments

//

01/05/2020

if (condition){
# True Block
}
else{
# False Block
}

Import-Module WebAdministration

if(Test-Path IIS:\AppPools\reddy)
{
Write-warning "The following block Already Exists"
#Removing existing App Pool
Remove-Item IIS:\AppPools\reddy -Force -Recurse -Verbose
# Create New pool
New-WebAppPool -Name Reddy -Force -Verbose
}

else
{
Write-warning "The following block doesnot Exists. So creating New"
#create newweb app pool cmdlet
New-WebAppPool -Name Reddy -Force -Verbose
 
}

# To Remove restriction error
$ Get-ExecutionPolicy
$ Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Verbose
Give File path to execute
'H:\AZURE\POWER SHELL PROGRAM\IF condition to create webappPool.ps1'

param(
    [parameter (Mandatory=$true)]
    [string]$pool
)


Import-Module webadministration

if(Test-path IIS:\AppPools\$pool)
{
    # If above condition is true then this block statement will be execute
    Write-Warning " The following Application Pool:$pool Already exist"
    # Removing the existing application Pool
    #Remove-WebAppPool
    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose

}
else{
    # If above if condition failed then this else block statements will execute
    Write-Host "The followig Application Pool:$pool deos not exist. Hence creating new" -ForegroundColor Red
   
}

   #create new-app pool
    New-WebAppPool -Name $pool -Force -Verbose

    # fetch the applicaition pool using get-item and store the value into variable $result 

    $result=Get-Item IIS:\AppPools\$pool -Force -Verbose

    #modify queuelength = 7000

    $result.queueLength=7000

    # managed run time version  v2.0

    $result.managedRuntimeVersion="v2.0"

    #manage pipeline mode as  Classic

    $result.managedPipelineMode="Classic"

    # enable32bit appon win 64 set as True

    $result.enable32BitAppOnWin64=$true

    # set the above new values to existing app-pool

    $result | Set-Item -Force -Verbose

02/05/2020

param(
  [parameter (Mandatory=$true)]
  [string]$Pool,
  [parameter (Mandatory=$true)]
  [string]$Version,
  [parameter (Mandatory=$true)]
  [string]$mode,
  [parameter (Mandatory=$true)]
  [bool]$enable32bit,
  [parameter (Mandatory=$true)]
  [int]$queuelength

)
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

#check the App-pool name should not empty
if($Pool -ne "" -and $Pool -ne $null)
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if($Version -ne "" -and $Version -ne $null)
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if($mode -ne $null -and $mode -ne "")
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if($queuelength -ge 10 -and $queuelength -le 65535){

$result.queueLength=$queuelength
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}

#update enable32bit (value should True or False)
if("$enable32bit" -ne $null -and "$enable32bit" -ne "")
{
if($enable32bit -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}



05/05/2020
App pool Identity
1. Build-In Account
  a. Local Service
  b. Local System
  c. Network Service
  d. App pool Identity
2. Custom Account
https://www.advancedinstaller.com/user-guide/iis-app-pool-identity.html

param(
  
 [string[]]$Pools,
 $Version,
 $mode,
 $enable32bit,
 $queuelength,
 $identiytype,
 $user,
 $password

)

$Pool="abc","xyz","123"
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

foreach ($pool in $Pools){

#check the App-pool name should not empty
if(-not([string]::IsNullOrWhiteSpace($Pool)))
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if(-not([string]::IsNullOrWhiteSpace($Version)))
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if(-not([string]::IsNullOrWhiteSpace($mode)))
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if(-not([string]::IsNullOrWhiteSpace("$queuelength"))){
if(([convert]::ToInt16($queuelength) -ge 10) -and ([convert]::ToInt16($queuelength) -le 65535)){

$result.queueLength=[convert]::ToInt64($queuelength)
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}
} # end of main if validation
else{
Write-Error -Message " Queuelength should not be null" -ErrorAction Stop
}

#update enable32bit (value should True or False)
if(-not([string]::IsNullOrWhiteSpace("$enable32bit")))
{
if("$enable32bit" -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

#Working with identitytype
if(-not([string]::IsNullOrWhiteSpace($identiytype)))
{
    if($identiytype -eq "LocalService")
    {
        $result.processModel.identityType="LocalService"
    }
    elseif($identiytype -eq "LocalSystem")
    {
        $result.processModel.identityType="LocalSystem"
    }
    elseif($identiytype -eq "NetworkService")
    {
        $result.processModel.identityType="NetWorkService"
    }
    elseif($identiytype -eq "SpecificUser")
    {
        $result.processModel.identityType="SpecificUser"
        $result.processModel.userName=$user
        $result.processModel.password=$password
    }
    else{
        Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor Green
        $result.processModel.identityType="Applicationpoolidentiy"
    }

}
else{
    Write-warnig -Message "Identity should not be empty and values must be Local System, Local Service, Network Service, Application-pool identity and Specific . By default Applicationpoolidentiy was set"
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}
}

07/05/2020
<APPpool.json> file

{
    "Name": "Kumar",
    "Version": "v2.0",
    "Mode": "Classic",
    "QueLength": 9909,
    "Enable32bit": true,
    "identityType": "LocalSystem",
    "UserName": "",
    "Password": ""
}

<AppPool.ps1> file

$data = Get-Content -Path H:\Azure\POWERSHELL\appPool.json | ConvertFrom-Json

$pool = $data.Name
$version = $data.Version
$mode = $data.Mode
$quelength = $data.QueLength
$enable32bit = $data.Enable32bit
$identitytype = $data.identityType
$username = $data.Username
$password = $data.Password

if(![string]::IsNullOrWhiteSpace($pool))
    {
        Import-Module webAdministration
        if(Test-Path IIS:\AppPools\$pool)
        {
            Write-Warning "The Application pool: $pool already exists, so removing the pool"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -verbose
            Write-Host "The AppPool: $pool deleted successfully" -ForegroundColor Green
        }
        else
        {
            Write-Host "The Application Pool: $pool does not exist, hence creating new one." -ForegroundColor White
        }

        New-WebAppPool -Name $pool -Force -Verbose
        Write-Host "The AppPool: $pool created successfully" -ForegroundColor Green

        $result =  Get-Item IIS:\AppPools\$pool -Force -verbose

        #Version
        if(![string]::IsNullOrWhiteSpace($version))
        {
            if($version -eq "v2.0" -or $version -eq "v4.0")
            {
                $result.managedRuntimeVersion = $version
            }
            elseif($version -eq "No Managed Code")
            {
                $result.managedRuntimeVersion = ""
            }
            else
            {
                Write-Error -Message "Invalid Version value. Version should be v2.0/v4.0/No Managed Code" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Version should not be empty" -ErrorAction Stop
        }

        #Mode
        if(![string]::IsNullOrWhiteSpace($mode))
        {
            if($mode -eq "Integrated" -or $mode -eq "Classic")
            {
                $result.managedPipelineMode = $mode
            }
            else
            {
                Write-Error -Message "Invalid Mode value, mode should be Integrated/Classic" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Mode should not be empty" -ErrorAction Stop
        }

        #Queue Length
        if(![string]::IsNullOrWhiteSpace($quelength))
        {
            if(([convert]::ToInt32($quelength) -ge 10) -and ([convert]::ToInt32($quelength) -le 65535))
            {
                $result.queueLength = [Convert]::ToInt32($quelength)
            }
            else
            {
                Write-Error -Message "Invalid Range Passed, range should be 10 to 65535" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Queue Length Should not be empty" -ErrorAction Stop
        }

        #Enable32bit
        if(![string]::IsNullOrWhiteSpace($enable32bit))
        {
            if("$enable32bit" -eq "True")
            {
                $result.enable32BitAppOnWin64 = $true
            }
            else
            {
                $result.enable32BitAppOnWin64 = $false
            }
        }
        else
        {
            Write-Error -Message "Enable32bit should not be empty" -ErrorAction Stop
        }

        #Identity Type
        if(![string]::IsNullOrWhiteSpace($identitytype))
        {
            if($identitytype -eq "LocalSystem")
            {
                $result.processModel.identityType = "LocalSystem"
            }
            elseif($identitytype -eq "LocalService")
            {
                $result.processModel.identityType = "LocalService"
            }
            elseif($identitytype -eq "NetworkService")
            {
                $result.processModel.identityType = "NetworkService"
            }
            elseif($identitytype -eq "SpecificUser")
            {
                $result.processModel.identityType = $identitytype
                $result.processModel.userName = $username
                $result.processModel.password = $password
            }
            else
            {
                $result.processModel.identityType = "ApplicationPoolIdentity"
            }
        }
        else
        {
            Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor White
            Write-Error -Message "Identity Type should not be empty" -ErrorAction Stop
        }

        $result | Set-Item -Force -Verbose
    }
    else
    {
        Write-Error -Message "The Application name should not be empty" -ErrorAction Stop
    }
	
	
---------------------------------

$Data=Get-Content -Path D:\Devops\AZ-800\pool.json | ConvertFrom-Json
#load the JSON values into  local varaibles

$pool=$data.Name
$version=$Data.version
$mode=$Data.mode
$queuelength=$Data.queuelength
$enable32bit=$Data.enable32bit
$identity=$Data.identitytype
$user=$Data.username
$password=$Data.password

#validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration -Verbose
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}


{
    "Name":"Json",
    "version":"v4.0",
    "mode":"Integrated",
    "queuelength":9999,
    "enable32bit":false,
    "identitytype":"SpecificUser",
    "username":"Test80",
    "password":"India@123"

}	

08/05/2020
$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.userName
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force -Verbose
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
}


----------

{
    "IISDeploy":{
        "AppPools":[
            {"First":{"Name":"FirstApp","version":"v2.0","mode":"Classic","queuelength":1111,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Second":{"Name":"Raja","version":"v2.0","mode":"Classic","queuelength":1112,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Third":{"Name":"Shekar","version":"v4.0","mode":"Integrated","queuelength":1113,"enable32bit":false,"identitytype":"LocalSystem","username":"RAJA","password":"crsreddy1447"}},
            {"Fourth":{"Name":"Reddy","version":"v4.0","mode":"Integrated","queuelength":8855,"enable32bit":false,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Fifth":{"Name":"FifthApp","version":"v2.0","mode":"Classic","queuelength":3333,"enable32bit":true,"identitytype":"LocalService","username":"RAJA","password":"crsreddy1447"}}
        ]
    }

}


TASK: How to handle custome app-pool execution  (selected app-pool execution )

----------
09/05/2020


param(
    [parameter (Mandatory=$true)]
    [string[]]$components
)

$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($components.Length -ne 0){
foreach($item in $components){
    Write-Host "Working on selected app-pool:$item" -ForegroundColor Green
    if($Apppools -contains $item){
            Write-Host "Working on App-pool :$item" -ForegroundColor Green
            ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
            # load the variables from json for specific app-pool
            
            $pool=$i.$item.Name
            $version=$i.$item.version
            $mode=$i.$item.mode
            $queuelength=$i.$item.queuelength
            $enable32bit=$i.$item.enable32bit
            $identity=$i.$item.identityType
            $user=$i.$item.username
            $password=$i.$item.password
    
            #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
    if(-not ([string]::IsNullOrWhiteSpace($pool))){
        #import module webadministration
        Import-Module webadministration
        #test the app-pool  exist or not . if exist then delete or set mesaage
        if(Test-Path IIS:\AppPools\$pool){
            Write-Warning "The given App-pool:$pool already exist. Hence removing"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
        }
        else {
            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
        } 
        
        #create new webapppool
        New-WebAppPool -Name $pool -Force
        #load the above created app-pool into local varaible
        $result=Get-Item IIS:\AppPools\$pool -Force
    
        #validate managed runtime version
        if(-not([string]::IsNullOrWhiteSpace($version))){
            if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                $result.managedRuntimeversion=$version
            }
            elseif($version -eq "No Managed Code"){
                $result.managedRuntimeversion=""
            }
            else{
                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message " version should not be empty" -ErrorAction Stop
        }
    
        #validate managed pipeline mode
        if(-not([string]::IsNullOrWhiteSpace($mode))){
            if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                $result.ManagedPipelineMode=$mode
            }
            else {
                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
        }
        #validate queuelength
        if(-not([string]::IsNullOrWhiteSpace($queuelength))){
            if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                $result.queuelength=[convert]::ToInt64($queuelength)
            }
            else {
                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
            }
        }
        else {
            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
        }
        #validate enable32bit
        if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
            if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                $result.enable32BitAppOnWin64=$enable32bit
            }
            else {
                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
        }
    
        #validate identity
        if(-not ([string]::IsNullOrWhiteSpace($identity))){
            if($identity -eq "LocalSystem"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "LocalService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "NetworkService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "SpecificUser"){
                $computer=$env:COMPUTERNAME
                Add-type -AssemblyName system.directoryservices.AccountManagement
                $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                $credstatus=$creds.ValidateCredentials($user, $password)
                if($credstatus -eq "true"){
                    $result.processModel.identityType="SpecificUser"
                    $result.processModel.userName=$user
                    $result.processModel.password=$password
                }
                else {
                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                }
            }
            else{
                Write-Warning "No matching identitytype found .hence applying default" 
                $result.Processmodel.identitytype="ApplicationPoolIdentity"
            }
        }
        else{
            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
        }
    
        $result |Set-Item -Force -Verbose
    }# end of main if pool
    else{
        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
    }
    
        
    }
    else{
        Write-Error -Message " the given component : $item doesnot exist in JSON" -ErrorAction 
    }
}
}
else{
if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.user
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
} 
}

------------------
12/05/2020

{
    "IISDeploy":{
        "Sites":[
            {"Google":{"Name":"Google","port":80,"physicalpath":"D:/Devops/IIS/Sites","Apppool":"Google"}}
        ]
    } 
}
$data=Get-Content -Path H:\AZURE\POWERSHELL\sites.json | ConvertFrom-Json
#Declare Empty Variable
$sites=@()
# Assigning json value to enpty variable
($data.IISDeploy.Sites).Foreach{
    $sites+=$_.psobject.properties.name
    
}
#validate sites length should not be 0
if($sites.length -ne 0)
{
    foreach($item in $sites)
    {
        Write-Host "Working on Sites" -ForegroundColor Green
        ($j=$data.IISDeploy.Sites)|Where-Object{$_.Name -eq $item}
        $sites=$j.$item.Name
        $port=$j.$item.port
        $physicalpath=($j.$item.physicalpath).Replace("/","\")
        $pool=$j.$item.Apppool

        # Valid site name should not be empty
        if($sites.length -ne 0)
        {
            Import-Module WebAdministration
            if(Test-Path IIS:\Sites\$sites)
            {
                Write-Warning "The given site :$sites found. Hence deleting"
                Remove-Item IIS:\Sites\$sites -Force -Verbose -Recurse
            }
            else 
            {
                Write-Host "No site found with name of :$sites. hence creating new" -ForegroundColor Green 
                
            }
            #Validate physical path
            if ($physicalpath.Length -ne 0) 
            {
                #Test the physical path
                if (Test-Path $physicalpath\$sites) 
                {
                    Write-Warning "Physicalpath :$physicalpath already exist .hence Deleting"
                    Remove-Item $physicalpath\$sites -Force -Recurse -Verbose
                }
                else 
                {
                    Write-Host "Physicalpath :$physicalpath\$sites doesnot exit. Hence creating new" -ForegroundColor Green
                }
                #create physical Path
                New-Item $physicalpath\$sites -ItemType Directory -Force -Verbose


            }
            else
            {
                Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
            } # end of the physical path condition
            #validate the port
            if($port.length -ne 0)
            {
                New-Website -Name $sites -Port $port -PhysicalPath $physicalpath -ApplicationPool $pool -Force -ErrorAction Stop
            }
            else
            {
                Write-Error "Port number should not be empty .hence aborting the process" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop 
        }
    }
}
else
{
    Write-Error -Message "Sites length should not Zero. please verify JSON" -ErrorAction stop
}


-----------------
13/05/2020

$Data=Get-Content -Path H:\AZURE\POWERSHELL\sitespool.json |ConvertFrom-Json

#decalre empty array
$sites=@()
($Data.IISDeploy.Sites).ForEach{$sites+=$_.psobject.properties.name}

#validate sites length should not be 0
if($sites.Length -ne 0){foreach($item in $sites)
    {
        Write-Host "Working on website: $item" -ForegroundColor Green
        ($j=$Data.IISDeploy.Sites)|Where-Object{$_.Name -eq $item}
            $sites=$j.$item.Name
            $port=$j.$item.port
            $physicalpath=($j.$item.physicalpath).Replace("/","\")
            $Apppool=$j.$item.Apppool

            if($Apppool.Length -ne 0)
            {
                Write-Host " Working on App-pool:$Apppool deployment" -ForegroundColor green
                ($i=$Data.IISDeploy.AppPools)| Where-Object{$_.name -eq $Apppool}
                # load the variables from json for specific app-pool
                    $pool=$i.$Apppool.name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identitytype
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
                        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
                if(-not ([string]::IsNullOrWhiteSpace($pool)))
                {
                    #import module webadministration
                    Import-Module webadministration
                    #test the app-pool  exist or not . if exist then delete or set mesaage
                    if(Test-Path IIS:\AppPools\$pool)
                    {
                        Write-Warning "The given App-pool:$pool already exist. Hence removing"
                        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                    }
                    else 
                    {
                        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                    } 
                    
                    #create new webapppool
                    New-WebAppPool -Name $pool -Force
                    #load the above created app-pool into local varaible
                    $result=Get-Item IIS:\AppPools\$pool -Force
                
                    #validate managed runtime version
                    if(-not([string]::IsNullOrWhiteSpace($version)))
                    {
                        if(($version -eq "v2.0") -or ($version -eq "v4.0"))
                        {
                            $result.managedRuntimeversion=$version
                        }
                        elseif($version -eq "No Managed Code")
                        {
                            $result.managedRuntimeversion=""
                        }
                        else
                        {
                            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message " version should not be empty" -ErrorAction Stop
                    }
                
                    #validate managed pipeline mode
                    if(-not([string]::IsNullOrWhiteSpace($mode)))
                    {
                        if(($mode -eq "Integrated") -or ($mode -eq "Classic"))
                        {
                            $result.ManagedPipelineMode=$mode
                        }
                        else 
                        {
                            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                    }
                    #validate queuelength
                    if(-not([string]::IsNullOrWhiteSpace($queuelength)))
                    {
                        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535))
                        {
                            $result.queuelength=[convert]::ToInt64($queuelength)
                        }
                        else 
                        {
                            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                    }
                    #validate enable32bit
                    if(-not([string]::IsNullOrWhiteSpace($enable32bit)))
                    {
                        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False"))
                        {
                            $result.enable32BitAppOnWin64=$enable32bit
                        }
                        else 
                        {
                            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                        }
                    }
                    else 
                    {
                        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                    }
                
                    #validate identity
                    if(-not ([string]::IsNullOrWhiteSpace($identity)))
                    {
                        if($identity -eq "LocalSystem")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "LocalService")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "NetworkService")
                        {
                            $result.Processmodel.Identitytype=$identity
                        }
                        elseif($identity -eq "SpecificUser")
                        {
                            $computer=$env:COMPUTERNAME
                            Add-type -AssemblyName system.directoryservices.AccountManagement
                            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                            $credstatus=$creds.ValidateCredentials($user, $password)
                            if($credstatus -eq "true")
                            {
                                $result.processModel.identityType="SpecificUser"
                                $result.processModel.userName=$user
                                $result.processModel.password=$password
                            }
                            else 
                            {
                                Write-Error -Message "Invalid credentials" -ErrorAction Stop
                            }
                        }
                        else
                        {
                            Write-Warning "No matching identitytype found .hence applying default" 
                            $result.Processmodel.identitytype="ApplicationPoolIdentity"
                        }
                    }
                    else
                    {
                        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                    }
                
                    $result |Set-Item -Force -Verbose
                }# end of main if pool
                else
                {
                    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
                }
                
                    


            }
            else 
            {
                Write-Error -Message "Pool name should not be empty. Hence aborting the process" -ErrorAction stop
            }
            #valite sitename should not be empty
            if($sites.Length -ne 0)
            {
                #import the module webadministration
                Import-Module WebAdministration
                if(Test-Path IIS:\Sites\$sites)
                {
                    Write-Warning " the given site : $sites found .Hence deleting"
                    Remove-Item IIS:\Sites\$sites -Force -Recurse -Verbose
                }
                else
                {
                    Write-Host "No site found with name of :$sites. hence creating new" -ForegroundColor Green
                }

                #validate physicalpath 
                if($physicalpath.Length -ne 0)
                {
                    # test the physicalpath 
                    if(Test-path $physicalpath\$sites)
                    {
                        Write-Warning "Physicalpath :$physicalpath already exist .hence Deleting"
                        Remove-Item $physicalpath\$sites -Force -Recurse -Verbose
                    }
                    else
                    {
                        Write-Host "Physicalpath :$physicalpath\$site doesnot exit. Hence creating new" -ForegroundColor Green
                    }
                    #creating physicalpath
                    New-Item $physicalpath\$sites -ItemType Directory -Force -Verbose

                }
                else
                {
                    Write-Error -message "Physicalpath should not be null. please verify JOSN or declared variables "  -ErrorAction Stop
                } # end physicalpath condition

                #validate port and create newwebsite
                if($port.length -ne 0)
                {
                    New-Website -Name $sites -Port $port -PhysicalPath $physicalpath -ApplicationPool $pool -Force -ErrorAction Stop
                }
                else
                {
                    Write-Error "Port numbe should not be empty .hence aborting the process" -ErrorAction Stop
                }
            }
            else
            {
                Write-Error -Message "Site name should not be null or empty" -ErrorAction Stop
            }
            
    }
}
else
{
    Write-Error -Message "Sites length should not Zero. please verify JSON" -ErrorAction stop
}

<JSON>

{
    "IISDeploy":{
        "AppPools":[
            {"Raja":{"name":"Raja","version":"v2.0","mode":"Classic","queuelength":4444,"enable32bit":true,"identitytype":"LocalSystem","user":"","password":""}},
            {"Shekar":{"name":"Shekar","version":"v4.0","mode":"Integrated","queuelength":5555,"enable32bit":false,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}},
            {"Reddy":{"name":"Reddy","version":"v2.0","mode":"Classic","queuelength":6666,"enable32bit":true,"identitytype":"LocalService","user":"","password":""}},
            {"CRSR":{"name":"CRSR","version":"v4.0","mode":"Integrated","queuelength":7777,"enable32bit":false,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}},
            {"SIVA":{"name":"SIVA","version":"v2.0","mode":"Classic","queuelength":9999,"enable32bit":true,"identitytype":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"Google":{"Name":"Google","port":85,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Raja"}},
            {"Microsoft":{"Name":"Microsoft","port":81,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Shekar"}},
            {"CTS":{"Name":"CTS","port":82,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Reddy"}},
            {"Eron":{"Name":"Eron","port":83,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"CRSR"}},
            {"GL":{"Name":"GL","port":84,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"SIVA"}}
            

        ]
    }
}

------------------
15/05/2020

#Load the data from JSON
$Data=get-content -Path H:\AZURE\POWERSHELL\Auth.json|ConvertFrom-Json

#Declare empty array for sites
$sites=@() # empty array means 0 objects

#let gather sites information from JSON
($Data.IISDeploy.Sites).ForEach{
    $sites+=$_.psobject.properties.name
}

#validate sites.length
if($sites.Length -ne 0){
    foreach($item in $sites){
        Write-host "Working on Site : $item deployment" -foregroundcolor green
        ($j=$Data.IISDeploy.Sites)|Where-Object {$_.Name -eq $item}

            $site=$j.$item.Name
            $port=$j.$item.port
            $physicalpath=($j.$item.physicalpath).Replace("/","\")
            $Apppool=$j.$item.Apppool
            $anonymous=$j.$item.Anonymous
            $windows=$j.$item.windows

            # validate app-pool name and initate the process for app-pool deployment
            if($Apppool.Length -ne 0){
                # load the app-pool information from JSON
                ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $Apppool}
                
                    Write-Host "Working on App-pool :$item" -ForegroundColor Green
                    # load the variables from json for specific app-pool
                    
                    $pool=$i.$Apppool.Name
                    $version=$i.$Apppool.version
                    $mode=$i.$Apppool.mode
                    $queuelength=$i.$Apppool.queuelength
                    $enable32bit=$i.$Apppool.enable32bit
                    $identity=$i.$Apppool.identity
                    $user=$i.$Apppool.user
                    $password=$i.$Apppool.password
            
                    #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
            if(-not ([string]::IsNullOrWhiteSpace($pool))){
                #import module webadministration
                Import-Module webadministration
                #test the app-pool  exist or not . if exist then delete or set mesaage
                if(Test-Path IIS:\AppPools\$pool){
                    Write-Warning "The given App-pool:$pool already exist. Hence removing"
                    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
                }
                else {
                    Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
                } 
                
                #create new webapppool
                New-WebAppPool -Name $pool -Force
                #load the above created app-pool into local varaible
                $result=Get-Item IIS:\AppPools\$pool -Force
            
                #validate managed runtime version
                if(-not([string]::IsNullOrWhiteSpace($version))){
                    if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                        $result.managedRuntimeversion=$version
                    }
                    elseif($version -eq "No Managed Code"){
                        $result.managedRuntimeversion=""
                    }
                    else{
                        Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message " version should not be empty" -ErrorAction Stop
                }
            
                #validate managed pipeline mode
                if(-not([string]::IsNullOrWhiteSpace($mode))){
                    if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                        $result.ManagedPipelineMode=$mode
                    }
                    else {
                        Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
                }
                #validate queuelength
                if(-not([string]::IsNullOrWhiteSpace($queuelength))){
                    if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                        $result.queuelength=[convert]::ToInt64($queuelength)
                    }
                    else {
                        Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
                    }
                }
                else {
                    Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
                }
                #validate enable32bit
                if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
                    if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                        $result.enable32BitAppOnWin64=$enable32bit
                    }
                    else {
                        Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
                    }
                }
                else {
                    Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
                }
            
                #validate identity
                if(-not ([string]::IsNullOrWhiteSpace($identity))){
                    if($identity -eq "LocalSystem"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "LocalService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "NetworkService"){
                        $result.Processmodel.Identitytype=$identity
                    }
                    elseif($identity -eq "SpecificUser"){
                        $computer=$env:COMPUTERNAME
                        Add-type -AssemblyName system.directoryservices.AccountManagement
                        $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                        $credstatus=$creds.ValidateCredentials($user, $password)
                        if($credstatus -eq "true"){
                            $result.processModel.identityType="SpecificUser"
                            $result.processModel.userName=$user
                            $result.processModel.password=$password
                        }
                        else {
                            Write-Error -Message "Invalid credentials" -ErrorAction Stop
                        }
                    }
                    else{
                        Write-Warning "No matching identitytype found .hence applying default" 
                        $result.Processmodel.identitytype="ApplicationPoolIdentity"
                    }
                }
                else{
                    Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
                }
            
                $result |Set-Item -Force -Verbose
            }# end of main if pool
            else{
                Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
            }
            
                
            }
            else{
                Write-Error -Message "Apppool cannot be empty. please validate JSON. Process getting aborted" -ErrorAction Stop
            }

            #begin site deployment
            if($site.Length -ne 0){
                Import-Module webadministration
                if(Test-Path IIS:\Sites\$site){
                    Write-warning "Sites already exist with name: $site. Hence deleting" 
                    Remove-item IIS:\Sites\$site -Force -Recurse -Verbose
                }
                else{
                    Write-Host "No Site found with name of $site. hence creating new" -ForegroundColor Green
                }
                #validate physicalpath
                if(Test-Path $physicalpath\$site){
                    Write-Warning " Physcialpath : $physicalpath\$site already exist. Hecne removing"
                    Remove-Item $physicalpath\$site -Force -Recurse -Verbose
                }
                else{
                    Write-Host " No physcialpath found .Hence creating new" -ForegroundColor Green
                }

                New-Item $physicalpath\$site -ItemType Directory -Force -Verbose
                #validate port
                if(($port.Length -ne 0) -and ([convert]::ToInt16($port) -ge 80)){
                    #create website
                    New-Website -Name $site -Port $port -PhysicalPath $physicalpath\$site -ApplicationPool $Apppool -Force -ErrorAction stop
                }
                else{
                    Write-Error -Message "Port value must be set" -ErrorAction Stop
                }

                # apply Anonymous authentication
                if($anonymous.length -ne 0){
                    if("$anonymous" -eq "True" -or "$anonymous" -eq "false"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/anonymousAuthentication -Value $($anonymous) -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    else{
                        Write-Warning "Invalid input provided . value must be true or false"
                    }
                }
                else{
                    Write-Error -message "Anonymous aunthentication value must be set" -ErrorAction Stop
                }
                # apply windows authentication
                if($windows.length -ne 0){
                    if($windows -eq "windows"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "basic"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "digest"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/digestAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    elseif($windows -eq "windowsbasic" -or $windows -eq "windowsandbasic"){
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/windowsAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                        Set-WebConfigurationProperty -Name enabled -Filter system.webServer/security/authentication/basicAuthentication -Value $true -PSPath IIS:\Sites\ -Location $site -Force -ErrorAction Stop -Verbose
                    }
                    else{
                        Write-warning "Windows authentication value must be windows, basic, digest, windowsbasic or windowsandbasic"
                    }
                
                }
                else {
                    Write-Error -Message "Windows Authentication value must be set" -ErrorAction stop
                }

            }
            else {
                Write-Error -message "Site name cannot be empty. Hence aborting the process" -ErrorAction stop            }
            
    }
}
else {
    Write-Error -Message "Sites length should not be zero. hence aborting the process" -ErrorAction Stop
}



{
    "IISDeploy":{
        "AppPools":[
            {"Aviva":{"Name":"Aviva","mode":"Integrated","version":"v4.0","queuelength":12345,"enable32bit":false,"identity":"SpecificUser","user":"RAJA","password":"crsreddy1447"}}
        ],
        "Sites":[
            {"Aviva":{"Name":"Aviva","port":89,"physicalpath":"H:/AZURE/IIS/Sites","Apppool":"Aviva","Anonymous":false,"windows":"windowsbasic" }}
        ]
    } 
}

Task : Component deployment for site

10 Sites -- 5 apppools ( 1 app pool need assign for two sites)

1,3,5,7,9  ( names of base numbers as components)



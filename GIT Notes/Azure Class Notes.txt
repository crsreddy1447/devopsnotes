29/04/2020 WINDOWS POWERSHELL
Configure iis
$ Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename
Store theses value in variable $<variable name>
$iisfeatures=Get-WindowsOptionalFeature -FeatureName IIS* -online | Select-Object featurename 

foreach($item in $iisfeatures.featurename){Enable-WindowsOptionalFeature -FeatureName $item -Online -Verbose}

cmdlet
commands are built in the form of verb-noun format
$ get-command    to list all commands
$ import-module webadministration -Verbose
$ get-command -Module webadministration

TO CHECK OPEN RUN(win+R) and type " inetmgr "
-Force is for conformation
-Verbose 

WIN ISE
Import-Module WebAdministration
New-WebAppPool -Name "RAJA" -Force   # To create a AppPools user 
$result=Get-Item IIS:\AppPools\RAJA -Force # To store appPool data to result 
$result |Format-List *                 # TO list the values stored in value
$result.managedPipelineMode="Classic"  # to change the parameter
$result.enable32BitAppOnWin64=$true  #for boolean true or false denote as a variable $true
$result.queueLength=65535
$result|Set-Item -Force -verbose       # to load the parameter in IIS

30/04/2020
Same as above with comments

//

01/05/2020

if (condition){
# True Block
}
else{
# False Block
}

Import-Module WebAdministration

if(Test-Path IIS:\AppPools\reddy)
{
Write-warning "The following block Already Exists"
#Removing existing App Pool
Remove-Item IIS:\AppPools\reddy -Force -Recurse -Verbose
# Create New pool
New-WebAppPool -Name Reddy -Force -Verbose
}

else
{
Write-warning "The following block doesnot Exists. So creating New"
#create newweb app pool cmdlet
New-WebAppPool -Name Reddy -Force -Verbose
 
}

# To Remove restriction error
$ Get-ExecutionPolicy
$ Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Verbose
Give File path to execute
'H:\AZURE\POWER SHELL PROGRAM\IF condition to create webappPool.ps1'

param(
    [parameter (Mandatory=$true)]
    [string]$pool
)


Import-Module webadministration

if(Test-path IIS:\AppPools\$pool)
{
    # If above condition is true then this block statement will be execute
    Write-Warning " The following Application Pool:$pool Already exist"
    # Removing the existing application Pool
    #Remove-WebAppPool
    Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose

}
else{
    # If above if condition failed then this else block statements will execute
    Write-Host "The followig Application Pool:$pool deos not exist. Hence creating new" -ForegroundColor Red
   
}

   #create new-app pool
    New-WebAppPool -Name $pool -Force -Verbose

    # fetch the applicaition pool using get-item and store the value into variable $result 

    $result=Get-Item IIS:\AppPools\$pool -Force -Verbose

    #modify queuelength = 7000

    $result.queueLength=7000

    # managed run time version  v2.0

    $result.managedRuntimeVersion="v2.0"

    #manage pipeline mode as  Classic

    $result.managedPipelineMode="Classic"

    # enable32bit appon win 64 set as True

    $result.enable32BitAppOnWin64=$true

    # set the above new values to existing app-pool

    $result | Set-Item -Force -Verbose

02/05/2020

param(
  [parameter (Mandatory=$true)]
  [string]$Pool,
  [parameter (Mandatory=$true)]
  [string]$Version,
  [parameter (Mandatory=$true)]
  [string]$mode,
  [parameter (Mandatory=$true)]
  [bool]$enable32bit,
  [parameter (Mandatory=$true)]
  [int]$queuelength

)
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

#check the App-pool name should not empty
if($Pool -ne "" -and $Pool -ne $null)
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if($Version -ne "" -and $Version -ne $null)
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if($mode -ne $null -and $mode -ne "")
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if($queuelength -ge 10 -and $queuelength -le 65535){

$result.queueLength=$queuelength
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}

#update enable32bit (value should True or False)
if("$enable32bit" -ne $null -and "$enable32bit" -ne "")
{
if($enable32bit -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}



05/05/2020
App pool Identity
1. Build-In Account
  a. Local Service
  b. Local System
  c. Network Service
  d. App pool Identity
2. Custom Account
https://www.advancedinstaller.com/user-guide/iis-app-pool-identity.html

param(
  
 [string[]]$Pools,
 $Version,
 $mode,
 $enable32bit,
 $queuelength,
 $identiytype,
 $user,
 $password

)

$Pool="abc","xyz","123"
# to work with IIS we need to import module " webadministration"
Import-Module Webadministration

foreach ($pool in $Pools){

#check the App-pool name should not empty
if(-not([string]::IsNullOrWhiteSpace($Pool)))
{
 # check the app-pool which is already exit or not. if yes then delete else provide message
if(Test-path IIS:\AppPools\$Pool)
{
    Write-Warning "The following App-pool:$Pool already exist. hence Deleting" 
    #remove app-pool using remove-item

    Remove-Item IIS:\AppPools\$pool -Force -Verbose -Recurse

}
else{
    Write-Host " The following App-pool:$Pool doesnot exist. hence creting new " -ForegroundColor Green

}

# to create new app-pool New-webapppool cmdlet

New-WebAppPool -Name $Pool -Force -Verbose

# get the existing app-pool from IIS using get-item cmdlet and store the resutl in varaible ($result)

$result=Get-Item IIS:\AppPools\$Pool -Force

# updating .net clr version with given value
if(-not([string]::IsNullOrWhiteSpace($Version)))
{
$result.managedRuntimeVersion=$Version
}
else{
    Write-Error -Message " Version value should not be empty" -ErrorAction Stop
}

#update managed pipeline mode
if(-not([string]::IsNullOrWhiteSpace($mode)))
{
$result.managedPipelineMode=$mode
}
else{
    Write-Error -Message " Mode value should not be empty" -ErrorAction stop
}

#update Queuelength
if(-not([string]::IsNullOrWhiteSpace("$queuelength"))){
if(([convert]::ToInt16($queuelength) -ge 10) -and ([convert]::ToInt16($queuelength) -le 65535)){

$result.queueLength=[convert]::ToInt64($queuelength)
}
else{
    Write-Error -Message "Invalid Range supplied . Range should be between 10 -65535" -ErrorAction stop
}
} # end of main if validation
else{
Write-Error -Message " Queuelength should not be null" -ErrorAction Stop
}

#update enable32bit (value should True or False)
if(-not([string]::IsNullOrWhiteSpace("$enable32bit")))
{
if("$enable32bit" -eq "True"){
$result.enable32BitAppOnWin64=$true
}
else{
$result.enable32BitAppOnWin64=$false
}
}
else{
    Write-Error -Message " Enable32bit value should not be null" -ErrorAction stop
}

#Working with identitytype
if(-not([string]::IsNullOrWhiteSpace($identiytype)))
{
    if($identiytype -eq "LocalService")
    {
        $result.processModel.identityType="LocalService"
    }
    elseif($identiytype -eq "LocalSystem")
    {
        $result.processModel.identityType="LocalSystem"
    }
    elseif($identiytype -eq "NetworkService")
    {
        $result.processModel.identityType="NetWorkService"
    }
    elseif($identiytype -eq "SpecificUser")
    {
        $result.processModel.identityType="SpecificUser"
        $result.processModel.userName=$user
        $result.processModel.password=$password
    }
    else{
        Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor Green
        $result.processModel.identityType="Applicationpoolidentiy"
    }

}
else{
    Write-warnig -Message "Identity should not be empty and values must be Local System, Local Service, Network Service, Application-pool identity and Specific . By default Applicationpoolidentiy was set"
}

# set the latest values to current app-pool by using set-item cmdlet

$result| set-item -Force -Verbose

}
else{
 Write-Error -Message " Pool name should not be empty" -ErrorAction stop
}
}

07/05/2020
<APPpool.json> file

{
    "Name": "Kumar",
    "Version": "v2.0",
    "Mode": "Classic",
    "QueLength": 9909,
    "Enable32bit": true,
    "identityType": "LocalSystem",
    "UserName": "",
    "Password": ""
}

<AppPool.ps1> file

$data = Get-Content -Path H:\Azure\POWERSHELL\appPool.json | ConvertFrom-Json

$pool = $data.Name
$version = $data.Version
$mode = $data.Mode
$quelength = $data.QueLength
$enable32bit = $data.Enable32bit
$identitytype = $data.identityType
$username = $data.Username
$password = $data.Password

if(![string]::IsNullOrWhiteSpace($pool))
    {
        Import-Module webAdministration
        if(Test-Path IIS:\AppPools\$pool)
        {
            Write-Warning "The Application pool: $pool already exists, so removing the pool"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -verbose
            Write-Host "The AppPool: $pool deleted successfully" -ForegroundColor Green
        }
        else
        {
            Write-Host "The Application Pool: $pool does not exist, hence creating new one." -ForegroundColor White
        }

        New-WebAppPool -Name $pool -Force -Verbose
        Write-Host "The AppPool: $pool created successfully" -ForegroundColor Green

        $result =  Get-Item IIS:\AppPools\$pool -Force -verbose

        #Version
        if(![string]::IsNullOrWhiteSpace($version))
        {
            if($version -eq "v2.0" -or $version -eq "v4.0")
            {
                $result.managedRuntimeVersion = $version
            }
            elseif($version -eq "No Managed Code")
            {
                $result.managedRuntimeVersion = ""
            }
            else
            {
                Write-Error -Message "Invalid Version value. Version should be v2.0/v4.0/No Managed Code" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Version should not be empty" -ErrorAction Stop
        }

        #Mode
        if(![string]::IsNullOrWhiteSpace($mode))
        {
            if($mode -eq "Integrated" -or $mode -eq "Classic")
            {
                $result.managedPipelineMode = $mode
            }
            else
            {
                Write-Error -Message "Invalid Mode value, mode should be Integrated/Classic" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Mode should not be empty" -ErrorAction Stop
        }

        #Queue Length
        if(![string]::IsNullOrWhiteSpace($quelength))
        {
            if(([convert]::ToInt32($quelength) -ge 10) -and ([convert]::ToInt32($quelength) -le 65535))
            {
                $result.queueLength = [Convert]::ToInt32($quelength)
            }
            else
            {
                Write-Error -Message "Invalid Range Passed, range should be 10 to 65535" -ErrorAction Stop
            }
        }
        else
        {
            Write-Error -Message "Queue Length Should not be empty" -ErrorAction Stop
        }

        #Enable32bit
        if(![string]::IsNullOrWhiteSpace($enable32bit))
        {
            if("$enable32bit" -eq "True")
            {
                $result.enable32BitAppOnWin64 = $true
            }
            else
            {
                $result.enable32BitAppOnWin64 = $false
            }
        }
        else
        {
            Write-Error -Message "Enable32bit should not be empty" -ErrorAction Stop
        }

        #Identity Type
        if(![string]::IsNullOrWhiteSpace($identitytype))
        {
            if($identitytype -eq "LocalSystem")
            {
                $result.processModel.identityType = "LocalSystem"
            }
            elseif($identitytype -eq "LocalService")
            {
                $result.processModel.identityType = "LocalService"
            }
            elseif($identitytype -eq "NetworkService")
            {
                $result.processModel.identityType = "NetworkService"
            }
            elseif($identitytype -eq "SpecificUser")
            {
                $result.processModel.identityType = $identitytype
                $result.processModel.userName = $username
                $result.processModel.password = $password
            }
            else
            {
                $result.processModel.identityType = "ApplicationPoolIdentity"
            }
        }
        else
        {
            Write-Host "Setting the default identiytype as Applicationpoolidentiy" -ForegroundColor White
            Write-Error -Message "Identity Type should not be empty" -ErrorAction Stop
        }

        $result | Set-Item -Force -Verbose
    }
    else
    {
        Write-Error -Message "The Application name should not be empty" -ErrorAction Stop
    }
	
	
---------------------------------

$Data=Get-Content -Path D:\Devops\AZ-800\pool.json | ConvertFrom-Json
#load the JSON values into  local varaibles

$pool=$data.Name
$version=$Data.version
$mode=$Data.mode
$queuelength=$Data.queuelength
$enable32bit=$Data.enable32bit
$identity=$Data.identitytype
$user=$Data.username
$password=$Data.password

#validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration -Verbose
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}


{
    "Name":"Json",
    "version":"v4.0",
    "mode":"Integrated",
    "queuelength":9999,
    "enable32bit":false,
    "identitytype":"SpecificUser",
    "username":"Test80",
    "password":"India@123"

}	

08/05/2020
$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.userName
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force -Verbose
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
}


----------

{
    "IISDeploy":{
        "AppPools":[
            {"First":{"Name":"FirstApp","version":"v2.0","mode":"Classic","queuelength":1111,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Second":{"Name":"Raja","version":"v2.0","mode":"Classic","queuelength":1112,"enable32bit":true,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Third":{"Name":"Shekar","version":"v4.0","mode":"Integrated","queuelength":1113,"enable32bit":false,"identitytype":"LocalSystem","username":"RAJA","password":"crsreddy1447"}},
            {"Fourth":{"Name":"Reddy","version":"v4.0","mode":"Integrated","queuelength":8855,"enable32bit":false,"identitytype":"SpecificUser","username":"RAJA","password":"crsreddy1447"}},
            {"Fifth":{"Name":"FifthApp","version":"v2.0","mode":"Classic","queuelength":3333,"enable32bit":true,"identitytype":"LocalService","username":"RAJA","password":"crsreddy1447"}}
        ]
    }

}


TASK: How to handle custome app-pool execution  (selected app-pool execution )

----------
09/05/2020


param(
    [parameter (Mandatory=$true)]
    [string[]]$components
)

$Data=Get-Content -Path H:\AZURE\POWERSHELL\appPOOL2.json | ConvertFrom-Json
#load the JSON values into  local varaibles

#create empty array
$Apppools=@()
#load the array object from json and append them into empty array variable
($data.IISDeploy.AppPools).ForEach{
    $Apppools+=$_.psobject.properties.Name
}

if($components.Length -ne 0){
foreach($item in $components){
    Write-Host "Working on selected app-pool:$item" -ForegroundColor Green
    if($Apppools -contains $item){
            Write-Host "Working on App-pool :$item" -ForegroundColor Green
            ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
            # load the variables from json for specific app-pool
            
            $pool=$i.$item.Name
            $version=$i.$item.version
            $mode=$i.$item.mode
            $queuelength=$i.$item.queuelength
            $enable32bit=$i.$item.enable32bit
            $identity=$i.$item.identityType
            $user=$i.$item.username
            $password=$i.$item.password
    
            #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
    if(-not ([string]::IsNullOrWhiteSpace($pool))){
        #import module webadministration
        Import-Module webadministration
        #test the app-pool  exist or not . if exist then delete or set mesaage
        if(Test-Path IIS:\AppPools\$pool){
            Write-Warning "The given App-pool:$pool already exist. Hence removing"
            Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
        }
        else {
            Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
        } 
        
        #create new webapppool
        New-WebAppPool -Name $pool -Force
        #load the above created app-pool into local varaible
        $result=Get-Item IIS:\AppPools\$pool -Force
    
        #validate managed runtime version
        if(-not([string]::IsNullOrWhiteSpace($version))){
            if(($version -eq "v2.0") -or ($version -eq "v4.0")){
                $result.managedRuntimeversion=$version
            }
            elseif($version -eq "No Managed Code"){
                $result.managedRuntimeversion=""
            }
            else{
                Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message " version should not be empty" -ErrorAction Stop
        }
    
        #validate managed pipeline mode
        if(-not([string]::IsNullOrWhiteSpace($mode))){
            if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
                $result.ManagedPipelineMode=$mode
            }
            else {
                Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
        }
        #validate queuelength
        if(-not([string]::IsNullOrWhiteSpace($queuelength))){
            if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
                $result.queuelength=[convert]::ToInt64($queuelength)
            }
            else {
                Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
            }
        }
        else {
            Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
        }
        #validate enable32bit
        if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
            if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
                $result.enable32BitAppOnWin64=$enable32bit
            }
            else {
                Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
            }
        }
        else {
            Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
        }
    
        #validate identity
        if(-not ([string]::IsNullOrWhiteSpace($identity))){
            if($identity -eq "LocalSystem"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "LocalService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "NetworkService"){
                $result.Processmodel.Identitytype=$identity
            }
            elseif($identity -eq "SpecificUser"){
                $computer=$env:COMPUTERNAME
                Add-type -AssemblyName system.directoryservices.AccountManagement
                $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
                $credstatus=$creds.ValidateCredentials($user, $password)
                if($credstatus -eq "true"){
                    $result.processModel.identityType="SpecificUser"
                    $result.processModel.userName=$user
                    $result.processModel.password=$password
                }
                else {
                    Write-Error -Message "Invalid credentials" -ErrorAction Stop
                }
            }
            else{
                Write-Warning "No matching identitytype found .hence applying default" 
                $result.Processmodel.identitytype="ApplicationPoolIdentity"
            }
        }
        else{
            Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
        }
    
        $result |Set-Item -Force -Verbose
    }# end of main if pool
    else{
        Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
    }
    
        
    }
    else{
        Write-Error -Message " the given component : $item doesnot exist in JSON" -ErrorAction 
    }
}
}
else{
if($Apppools.Length -ne 0){
    foreach($item in $Apppools){
        Write-Host "Working on App-pool :$item" -ForegroundColor Green
        ($i=$Data.IISDeploy.AppPools)|Where-Object{$_.Name -eq $item}
        # load the variables from json for specific app-pool
        
        $pool=$i.$item.Name
        $version=$i.$item.version
        $mode=$i.$item.mode
        $queuelength=$i.$item.queuelength
        $enable32bit=$i.$item.enable32bit
        $identity=$i.$item.identityType
        $user=$i.$item.user
        $password=$i.$item.password

        #validate pool name if($pool -ne "" -and $pool -ne $null) -- former method
if(-not ([string]::IsNullOrWhiteSpace($pool))){
    #import module webadministration
    Import-Module webadministration
    #test the app-pool  exist or not . if exist then delete or set mesaage
    if(Test-Path IIS:\AppPools\$pool){
        Write-Warning "The given App-pool:$pool already exist. Hence removing"
        Remove-Item IIS:\AppPools\$pool -Force -Recurse -Verbose
    }
    else {
        Write-Host "The given App-pool:$pool doesnot not exist. Hence creating new" -ForegroundColor Green
    } 
    
    #create new webapppool
    New-WebAppPool -Name $pool -Force
    #load the above created app-pool into local varaible
    $result=Get-Item IIS:\AppPools\$pool -Force

    #validate managed runtime version
    if(-not([string]::IsNullOrWhiteSpace($version))){
        if(($version -eq "v2.0") -or ($version -eq "v4.0")){
            $result.managedRuntimeversion=$version
        }
        elseif($version -eq "No Managed Code"){
            $result.managedRuntimeversion=""
        }
        else{
            Write-Error -Message "version value should be v2.0 or v4.0 or No Managed code" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message " version should not be empty" -ErrorAction Stop
    }

    #validate managed pipeline mode
    if(-not([string]::IsNullOrWhiteSpace($mode))){
        if(($mode -eq "Integrated") -or ($mode -eq "Classic")){
            $result.ManagedPipelineMode=$mode
        }
        else {
            Write-Error -Message "value should be Integrated or Classic" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "Mode value should not be null or emtpy and value should be Integrated or Classic"
    }
    #validate queuelength
    if(-not([string]::IsNullOrWhiteSpace($queuelength))){
        if(([convert]::ToInt64($queuelength)-ge 10) -and ([convert]::ToInt64($queuelength) -le 65535)){
            $result.queuelength=[convert]::ToInt64($queuelength)
        }
        else {
            Write-Error -Message "queuelength value should be between 10-65535" -ErrorAction stop
        }
    }
    else {
        Write-Error -Message "Queuelength value should not be null" -ErrorAction Stop
    }
    #validate enable32bit
    if(-not([string]::IsNullOrWhiteSpace($enable32bit))){
        if(("$enable32bit" -eq "True") -or ("$enable32bit" -eq "False")){
            $result.enable32BitAppOnWin64=$enable32bit
        }
        else {
            Write-Error -Message "Enable32bit value should be true|false or 1|0" -ErrorAction Stop
        }
    }
    else {
        Write-Error -Message "enable32bit values should not be null or empty" -ErrorAction stop
    }

    #validate identity
    if(-not ([string]::IsNullOrWhiteSpace($identity))){
        if($identity -eq "LocalSystem"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "LocalService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "NetworkService"){
            $result.Processmodel.Identitytype=$identity
        }
        elseif($identity -eq "SpecificUser"){
            $computer=$env:COMPUTERNAME
            Add-type -AssemblyName system.directoryservices.AccountManagement
            $creds=New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('machine', $computer)
            $credstatus=$creds.ValidateCredentials($user, $password)
            if($credstatus -eq "true"){
                $result.processModel.identityType="SpecificUser"
                $result.processModel.userName=$user
                $result.processModel.password=$password
            }
            else {
                Write-Error -Message "Invalid credentials" -ErrorAction Stop
            }
        }
        else{
            Write-Warning "No matching identitytype found .hence applying default" 
            $result.Processmodel.identitytype="ApplicationPoolIdentity"
        }
    }
    else{
        Write-Error -Message "Identiytype value should be LocalSystem or LocalService or NetworkService or SpecificUser or ApplicationPoolIdentity" -ErrorAction stop
    }

    $result |Set-Item -Force -Verbose
}# end of main if pool
else{
    Write-Error -Message "Pool name should not be empty. Hence aborting execution" -ErrorAction Stop
}

    }# end foreach loop
}
else{
    Write-Error -message "Apppools shouldnot be null. Please check your JSON file" -ErrorAction Stop
} 
}




